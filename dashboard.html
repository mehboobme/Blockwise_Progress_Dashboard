<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Blockwise Progress Dashboard - Federated Model</title>

  <!-- APS Viewer CSS -->
  <link rel="stylesheet" href="https://developer.api.autodesk.com/modelderivative/v2/viewers/7.*/style.min.css">

  <!-- SheetJS for Excel parsing -->
  <script src="https://cdn.sheetjs.com/xlsx-latest/package/dist/xlsx.full.min.js"></script>

  <!-- Custom CSS -->
  <link rel="stylesheet" href="css/styles.css">
</head>
<body>
  <!-- Header -->
  <header class="app-header">
    <div class="header-left">
      <img src="images/ROSHN Logo_with no text.gif" alt="Roshn Logo" class="header-logo">
      <h1>Construction Progress Dashboard</h1>
    </div>
    <div class="header-actions">
      <div id="authStatus" class="auth-status">
        <span id="authStatusText">Not logged in</span>
        <button id="loginBtn" class="btn btn-success">Login to Autodesk</button>
        <button id="logoutBtn" class="btn btn-secondary" style="display: none;">Logout</button>
      </div>
      <button id="toggleScheduleBtn" class="btn btn-secondary" onclick="window.toggleSchedulePanel()" style="display: none;">üìÖ Schedule</button>
      <button id="loadModelBtn" class="btn btn-primary" disabled>Load Model</button>
      <button id="analyzeBtn" class="btn btn-warning" disabled>Analyze Model</button>
    </div>
  </header>

  <!-- Main Container -->
  <div class="main-container">

    <!-- Sidebar -->
    <aside class="sidebar">

      <!-- Filters Panel -->
      <div class="panel">
        <h3>üîΩ Filters</h3>

        <div class="control-group">
          <label for="filterPhase">Phase:</label>
          <select id="filterPhase" disabled>
            <option value="">All</option>
          </select>
        </div>

        <div class="control-group">
          <label for="filterNeighborhood">Neighborhood:</label>
          <select id="filterNeighborhood" disabled>
            <option value="">All</option>
          </select>
        </div>

        <div class="control-group">
          <label for="filterBlock">Block:</label>
          <select id="filterBlock" disabled>
            <option value="">All</option>
          </select>
        </div>

        <div class="control-group">
          <label for="filterPlot">Plot:</label>
          <select id="filterPlot" disabled>
            <option value="">All</option>
          </select>
        </div>

        <button id="applyFiltersBtn" class="btn btn-primary btn-full" disabled>Apply Filters</button>
        <button id="clearFiltersBtn" class="btn btn-secondary btn-full" disabled>Clear Filters</button>
      </div>

      <!-- Controls Panel -->
      <div class="panel">
        <h3>üé® Visualization</h3>
        <div class="control-group">
          <label for="colorScheme">Color Scheme:</label>
          <select id="colorScheme" disabled>
            <option value="None">None</option>
            <option value="Block" selected>By Block</option>
            <option value="Component">By Component</option>
            <option value="Status">By Status</option>
          </select>
        </div>
      </div>

      <!-- Tools Panel -->
      <div class="panel">
        <h3>üõ†Ô∏è Tools</h3>
        <button id="fitViewBtn" class="btn btn-secondary btn-full" disabled>Fit to View</button>
        <button id="showAllBtn" class="btn btn-secondary btn-full" disabled>Show All</button>
        <button id="exportDataBtn" class="btn btn-secondary btn-full" disabled>Export Data</button>
      </div>

      <!-- Schedule Data Panel -->
      <div class="panel">
        <h3>üìÖ Schedule Data</h3>
        <div class="control-group">
          <label for="scheduleFileInput" style="font-size: 12px; color: #666;">Upload Excel File:</label>
          <input type="file" id="scheduleFileInput" accept=".xlsx,.xls" style="display: none;">
          <button id="uploadScheduleBtn" class="btn btn-primary btn-full">Upload Schedule</button>
          <div id="scheduleStatus" style="margin-top: 8px; font-size: 11px; color: #666;"></div>
        </div>
      </div>

      <!-- Legend -->
      <div class="panel" id="legend">
        <!-- Legend will be populated dynamically -->
      </div>

      <!-- Stats -->
      <div class="panel" id="stats">
        <!-- Stats will be populated dynamically -->
      </div>

    </aside>

    <!-- Viewer Container -->
    <main class="viewer-section">
      <div id="viewerContainer" class="viewer-container"></div>
      <div id="status" class="status">Ready - Login and load model to begin</div>
    </main>

  </div>

  <!-- APS Viewer JS -->
  <script src="https://developer.api.autodesk.com/modelderivative/v2/viewers/7.*/viewer3D.min.js"></script>

  <!-- Dashboard script -->
  <script type="module">
    import { CONFIG } from './js/config.js';
    import { viewerManager } from './js/viewer.js';
    import { embeddedDataManager } from './js/embeddedDataManager.js';
    import { embeddedColorManager } from './js/embeddedColorManager.js';
    import { authManager } from './js/auth.js';
    import { propertyPanel } from './js/propertyPanel.js';
    import { analyzePlotDistribution } from './js/plot-number-analysis.js';
    import { diagnosticAnalysis } from './js/diagnostic-property-analysis.js';
    import { findExactPropertyNames } from './js/find-exact-property-names.js';
    import { findVillaElements } from './js/find-villa-elements.js';
    import { searchForRealVillas } from './js/search-real-villas.js';
    import { exploreModelStructure } from './js/explore-model-structure.js';
    import { findVillaNodes } from './js/find-villa-nodes.js';
    import { exploreInstanceTree } from './js/explore-instance-tree.js';
    import { exploreFederatedModels } from './js/explore-federated-models.js';
    import { exploreDocumentStructure, extractVillaModelData } from './js/explore-document-structure.js';
    import { findNestedModels, checkModelReferences } from './js/find-nested-models.js';
    import { extractVillaDataFromNode } from './js/extract-villa-node-data.js';
    import { debugColorByNeighborhood } from './js/debug-color-neighborhood.js';
    import { testColoring } from './js/test-coloring.js';
    import { showInteractiveBlockList, hideBlockLabels } from './js/visual-block-identifier.js';
    import { debugBlockLabelSystem, testSingleLabel, fixPanelPosition } from './js/debug-block-labels.js';

    class Dashboard {
      constructor() {
        this.modelLoaded = false;
        this.dataAnalyzed = false;
        this.isAuthenticated = false;
      }

      async init() {
        console.log('üöÄ Initializing dashboard...');

        // Initialize auth
        authManager.initLoginListener();

        // Initialize property panel
        propertyPanel.initialize();

        // Setup UI listeners
        this.setupUIListeners();

        // Setup viewer callbacks
        this.setupViewerCallbacks();

        // Check auth status
        this.checkAuthStatus();

        console.log('‚úÖ Dashboard initialized');
      }

      setupUIListeners() {
        // Login/Logout
        document.getElementById('loginBtn')?.addEventListener('click', () => this.handleLogin());
        document.getElementById('logoutBtn')?.addEventListener('click', () => this.handleLogout());

        // Load model
        document.getElementById('loadModelBtn')?.addEventListener('click', () => this.loadModel());

        // Analyze model
        document.getElementById('analyzeBtn')?.addEventListener('click', () => this.analyzeModel());

        // Filters
        document.getElementById('applyFiltersBtn')?.addEventListener('click', () => this.applyFilters());
        document.getElementById('clearFiltersBtn')?.addEventListener('click', () => this.clearFilters());
        
        // Schedule upload
        document.getElementById('uploadScheduleBtn')?.addEventListener('click', () => {
          document.getElementById('scheduleFileInput').click();
        });
        
        document.getElementById('scheduleFileInput')?.addEventListener('change', async (e) => {
          const file = e.target.files[0];
          if (file) {
            await this.loadScheduleFile(file);
          }
        });

        // Color scheme
        document.getElementById('colorScheme')?.addEventListener('change', (e) => {
          if (this.dataAnalyzed) {
            this.applyColorScheme(e.target.value);
          } else {
            this.updateStatus('Please wait for model analysis to complete', 'warning');
          }
        });

        // Show all
        document.getElementById('showAllBtn')?.addEventListener('click', () => this.showAll());

        // Fit to view
        document.getElementById('fitViewBtn')?.addEventListener('click', () => viewerManager.fitToView());

        // Export data
        document.getElementById('exportDataBtn')?.addEventListener('click', () => this.exportData());

        // Auth success message
        window.addEventListener('message', (event) => {
          if (event.data.type === 'auth_success') {
            this.checkAuthStatus();
          }
        });
      }

      setupViewerCallbacks() {
        viewerManager.onSelectionChanged = async (dbIds) => {
          if (dbIds.length > 0) {
            // await this.showElementProperties(dbIds[0]);
          } else {
            // propertyPanel.hide();
          }
        };

        viewerManager.onGeometryLoaded = async () => {
          console.log('üìê Geometry loaded');
          // Auto-analyze model after geometry loads
          await this.analyzeModel();
        };
      }

      async loadModel() {
        try {
          this.updateStatus('Loading model (311k elements - this may take 1-2 minutes)...', 'info');

          // Initialize viewer
          await viewerManager.initialize(CONFIG.VIEWER.container);

          // Add progress tracking for large model
          let progressInterval = setInterval(() => {
            console.log('‚è≥ Large model loading in progress...');
          }, 5000);

          // Load model
          const identifier = CONFIG.MODEL_URN;
          if (!identifier) {
            clearInterval(progressInterval);
            throw new Error('No MODEL_URN in config.js');
          }

          console.log('Loading large model (311k elements)...');
          await viewerManager.loadModel(identifier);

          clearInterval(progressInterval);

          this.modelLoaded = true;
          console.log('‚úÖ Model load complete, instance tree:', viewerManager.instanceTree);
          this.updateStatus('Model loaded - Click "Analyze Model" button', 'success');

          // Enable basic controls
          this.enableControls();

          // Try auto-trigger with multiple retries
          let retries = 0;
          const tryAnalysis = async () => {
            retries++;
            console.log(`üîÑ Auto-analysis attempt ${retries}/5...`);

            if (this.dataAnalyzed) {
              console.log('‚úÖ Already analyzed, skipping');
              return;
            }

            if (viewerManager.instanceTree) {
              console.log('‚úÖ Instance tree ready, starting analysis');
              await this.analyzeModel();
            } else if (retries < 5) {
              console.warn(`‚ö†Ô∏è Instance tree not ready yet (attempt ${retries}/5), retrying in 2 seconds...`);
              setTimeout(tryAnalysis, 2000);
            } else {
              console.error('‚ùå Instance tree not ready after 5 attempts. Please click "Analyze Model" button manually.');
              this.updateStatus('Model loaded - Click "Analyze Model" to continue', 'warning');
            }
          };

          // Start first attempt after 2 seconds
          setTimeout(tryAnalysis, 2000);

        } catch (error) {
          console.error('‚ùå Model load error:', error);
          this.updateStatus('Failed to load model: ' + error.message, 'error');
        }
      }

      async analyzeModel() {
        if (!this.modelLoaded) {
          this.updateStatus('Load model first', 'warning');
          return;
        }

        // Check if viewer has instance tree
        if (!viewerManager.instanceTree) {
          console.warn('‚ö†Ô∏è Instance tree not ready yet, waiting 2 more seconds...');
          setTimeout(() => this.analyzeModel(), 2000);
          return;
        }

        try {
          this.updateStatus('Analyzing model properties (this may take a few minutes)...', 'info');
          console.log('üîç Starting model analysis...');

          // Analyze model with progress callback
          const progressCallback = (progress, message) => {
            this.updateStatus(`${message} - ${progress}% complete`, 'info');
          };

          const stats = await embeddedDataManager.analyzeModel(progressCallback);

          this.dataAnalyzed = true;
          console.log('‚úÖ Analysis complete:', stats);
          this.updateStatus(`Analysis complete: ${stats.phases} phases, ${stats.neighborhoods} neighborhoods, ${stats.blocks} blocks, ${stats.plots} plots`, 'success');

          // Populate filter dropdowns
          this.populateFilters();
          console.log('‚úÖ Filters populated');

          // Display stats
          this.displayStats(stats);

          // Auto-apply color scheme
          if (CONFIG.UI.AUTO_COLOR_BY) {
            await this.applyColorScheme(CONFIG.UI.AUTO_COLOR_BY);
          }

        } catch (error) {
          console.error('‚ùå Analysis error:', error);
          this.updateStatus('Failed to analyze model: ' + error.message, 'error');
        }
      }

      async applyColorScheme(scheme) {
        if (!this.dataAnalyzed) {
          this.updateStatus('Waiting for model analysis to complete...', 'warning');
          return;
        }

        if (scheme === 'None') {
          viewerManager.clearColors();
          this.updateStatus('Colors cleared', 'info');
          return;
        }

        try {
          this.updateStatus(`Applying ${scheme} color scheme...`, 'info');

          await embeddedColorManager.applyColorScheme(scheme);

          this.updateStatus(`${scheme} colors applied`, 'success');

          // Update legend
          this.updateLegend();

        } catch (error) {
          console.error('‚ùå Color scheme error:', error);
          this.updateStatus('Failed to apply colors: ' + error.message, 'error');
        }
      }

      colorByNeighborhood(selectedNeighborhood, filteredDbIds) {
        // Color blocks in selected neighborhood with different colors
        
        // Normalize neighborhood name to lowercase (to match stored keys)
        const normalizedNeighborhood = String(selectedNeighborhood).trim().toLowerCase();
        
        console.log(`üé® Coloring blocks in neighborhood ${normalizedNeighborhood}...`);

        // Large color palette with very distinct colors for blocks
        const colorPalette = [
          { r: 255, g: 0, b: 0 },       // Red
          { r: 0, g: 255, b: 0 },       // Green
          { r: 0, g: 0, b: 255 },       // Blue
          { r: 255, g: 255, b: 0 },     // Yellow
          { r: 255, g: 0, b: 255 },     // Magenta
          { r: 0, g: 255, b: 255 },     // Cyan
          { r: 255, g: 165, b: 0 },     // Orange
          { r: 128, g: 0, b: 128 },     // Purple
          { r: 0, g: 128, b: 128 },     // Teal
          { r: 255, g: 192, b: 203 },   // Pink
          { r: 165, g: 42, b: 42 },     // Brown
          { r: 128, g: 128, b: 0 },     // Olive
          { r: 0, g: 128, b: 0 },       // Dark Green
          { r: 128, g: 128, b: 128 },   // Gray
          { r: 255, g: 128, b: 0 },     // Dark Orange
          { r: 0, g: 255, b: 127 },     // Spring Green
          { r: 255, g: 0, b: 127 },     // Crimson
          { r: 127, g: 0, b: 255 },     // Electric Violet
          { r: 0, g: 127, b: 255 },     // Sky Blue
          { r: 255, g: 215, b: 0 },     // Gold
          { r: 100, g: 149, b: 237 },   // Cornflower Blue
          { r: 34, g: 139, b: 34 },     // Forest Green
          { r: 220, g: 20, b: 60 },     // Crimson Red
          { r: 0, g: 206, b: 209 },     // Dark Turquoise
          { r: 184, g: 134, b: 11 },    // Dark Goldenrod
          { r: 139, g: 69, b: 19 },     // Saddle Brown
          { r: 30, g: 144, b: 255 },    // Dodger Blue
          { r: 50, g: 205, b: 50 },     // Lime Green
          { r: 178, g: 34, b: 34 },     // Firebrick
          { r: 72, g: 209, b: 204 },    // Medium Turquoise
          { r: 255, g: 69, b: 0 },      // Red Orange
          { r: 46, g: 125, b: 50 },     // Material Green
          { r: 25, g: 103, b: 210 },    // Material Blue
          { r: 230, g: 124, b: 115 },   // Material Red
          { r: 76, g: 175, b: 80 },     // Material Light Green
          { r: 33, g: 150, b: 243 },    // Material Light Blue
          { r: 244, g: 67, b: 54 }      // Material Red Bright
        ];

        // Group DbIds by block
        const blockToDbIds = new Map();
        
        for (const dbId of filteredDbIds) {
          const elementInfo = embeddedDataManager.elementData.get(dbId);
          
          if (elementInfo) {
            // Normalize both values for comparison (sector from data is uppercase, normalizedNeighborhood is lowercase)
            const elementSectorNormalized = String(elementInfo.sector).trim().toLowerCase();
            
            if (elementSectorNormalized === normalizedNeighborhood) {
              const block = elementInfo.block;
              
              if (block) {
                if (!blockToDbIds.has(block)) {
                  blockToDbIds.set(block, []);
                }
                blockToDbIds.get(block).push(dbId);
              }
            }
          }
        }

        // Sort blocks numerically for consistent color assignment
        const sortedBlocks = Array.from(blockToDbIds.keys()).sort((a, b) => {
          const numA = parseInt(a) || 0;
          const numB = parseInt(b) || 0;
          return numA - numB;
        });

        // Apply different color to each block (in sorted order for consistency)
        let totalColored = 0;
        
        for (let i = 0; i < sortedBlocks.length; i++) {
          const block = sortedBlocks[i];
          const dbIds = blockToDbIds.get(block);
          
          // Assign color based on block index
          const color = colorPalette[i % colorPalette.length];
          color.a = 0.8;  // Add transparency
          
          viewerManager.setColor(dbIds, color);
          totalColored += dbIds.length;
          
          console.log(`  Block ${block}: ${dbIds.length} elements colored with RGB(${color.r},${color.g},${color.b})`);
        }

        console.log(`‚úÖ Colored ${totalColored} elements in ${blockToDbIds.size} blocks`);
      }

      async search(query) {
        if (!query || !this.dataAnalyzed) return;

        try {
          const plotNumber = query.trim();
          const dbIds = embeddedDataManager.getElementsByPlot(plotNumber);

          if (dbIds.length > 0) {
            viewerManager.isolate(dbIds);
            viewerManager.fitToView(dbIds);
            viewerManager.select(dbIds);
            this.updateStatus(`Found ${dbIds.length} elements for plot ${plotNumber}`, 'success');
          } else {
            this.updateStatus(`No elements found for plot ${plotNumber}`, 'warning');
          }

        } catch (error) {
          console.error('‚ùå Search error:', error);
          this.updateStatus('Search failed: ' + error.message, 'error');
        }
      }

      showAll() {
        viewerManager.showAll();
        viewerManager.clearSelection();
        this.updateStatus('Showing all elements', 'info');
      }

      async showElementProperties(dbId) {
        const elementData = embeddedDataManager.getElementData(dbId);

        if (!elementData) {
          propertyPanel.showNoData(dbId);
          return;
        }

        // Get full model properties
        const modelProps = await viewerManager.getProperties(dbId);

        // Create display data
        const displayData = [{
          project: elementData.project || 'N/A',
          phase: elementData.phase || 'N/A',
          block: elementData.block || 'N/A',
          plot: elementData.plot || 'N/A',
          villa: elementData.villa || 'N/A',
          component: elementData.component || 'N/A',
          plannedStart: elementData.plannedStart,
          plannedFinish: elementData.plannedFinish,
          completionDate: elementData.completionDate
        }];

        propertyPanel.renderProperties(displayData, modelProps);
        propertyPanel.panel.classList.add('visible');
      }

      displayStats(stats) {
        const statsDiv = document.getElementById('stats');
        if (!statsDiv) return;

        const overallStats = embeddedDataManager.getStats();

        statsDiv.innerHTML = `
          <div class="stats-card">
            <h4>üìä Model Statistics</h4>
            <p>Total Elements: ${stats.totalElements}</p>
            <p>Analyzed: ${stats.analyzed} (${stats.analysisRate}%)</p>
            <hr>
            <p>Phases: ${stats.phases}</p>
            <p>Neighborhoods: ${stats.neighborhoods}</p>
            <p>Blocks: ${stats.blocks}</p>
            <p>Plots: ${stats.plots}</p>
            <p>Components: ${stats.components}</p>
            <hr>
            <p>Completed: ${overallStats.completed}</p>
            <p>In Progress: ${overallStats.inProgress}</p>
            <p>Delayed: ${overallStats.delayed}</p>
            <p>Not Started: ${overallStats.notStarted}</p>
            <p><strong>Completion Rate: ${overallStats.completionRate}%</strong></p>
          </div>
        `;
      }

      populateFilters() {
        // Populate Phase dropdown
        const phaseSelect = document.getElementById('filterPhase');
        const phases = embeddedDataManager.getAllPhases();
        phaseSelect.innerHTML = '<option value="">All</option>';
        phases.forEach(phase => {
          phaseSelect.innerHTML += `<option value="${phase}">${phase.toUpperCase()}</option>`;
        });

        // Populate Neighborhood dropdown
        const neighborhoodSelect = document.getElementById('filterNeighborhood');
        const neighborhoods = embeddedDataManager.getAllNeighborhoods();
        neighborhoodSelect.innerHTML = '<option value="">All</option>';
        neighborhoods.forEach(neighborhood => {
          neighborhoodSelect.innerHTML += `<option value="${neighborhood}">${neighborhood.toUpperCase()}</option>`;
        });

        // Populate Block dropdown
        const blockSelect = document.getElementById('filterBlock');
        const blocks = embeddedDataManager.getAllBlocks();
        blockSelect.innerHTML = '<option value="">All</option>';
        blocks.forEach(block => {
          blockSelect.innerHTML += `<option value="${block}">${block.toUpperCase()}</option>`;
        });

        // Populate Plot dropdown
        const plotSelect = document.getElementById('filterPlot');
        const plots = embeddedDataManager.getAllPlots();
        plotSelect.innerHTML = '<option value="">All</option>';
        plots.forEach(plot => {
          plotSelect.innerHTML += `<option value="${plot}">${plot.toUpperCase()}</option>`;
        });
      }

      applyFilters() {
        if (!this.dataAnalyzed) {
          this.updateStatus('Analyze model first', 'warning');
          return;
        }

        const phase = document.getElementById('filterPhase').value;
        const neighborhood = document.getElementById('filterNeighborhood').value;
        const block = document.getElementById('filterBlock').value;
        const plot = document.getElementById('filterPlot').value;

        // Collect all elements to show based on filters
        let filteredDbIds = [];

        if (plot) {
          // If plot selected, show only that plot
          filteredDbIds = embeddedDataManager.getElementsByPlot(plot);
        } else if (block) {
          // If block selected, show entire block
          filteredDbIds = embeddedDataManager.getElementsByBlock(block);
        } else if (neighborhood) {
          // If neighborhood selected, show entire neighborhood
          filteredDbIds = embeddedDataManager.getElementsByNeighborhood(neighborhood);
        } else if (phase) {
          // If phase selected, show entire phase
          filteredDbIds = embeddedDataManager.getElementsByPhase(phase);
        }

        if (filteredDbIds.length > 0) {
          viewerManager.isolate(filteredDbIds);
          viewerManager.fitToView(filteredDbIds);
          
          // If neighborhood selected, show interactive block list
          if (neighborhood) {
            showInteractiveBlockList(neighborhood, filteredDbIds);
            // Enable schedule toggle button
            const scheduleBtn = document.getElementById('toggleScheduleBtn');
            if (scheduleBtn) scheduleBtn.style.display = 'inline-block';
          }
          
          this.updateStatus(`Filtered: ${filteredDbIds.length} elements`, 'success');
        } else {
          this.updateStatus('No elements match the selected filters', 'warning');
        }
      }

      clearFilters() {
        document.getElementById('filterPhase').value = '';
        document.getElementById('filterNeighborhood').value = '';
        document.getElementById('filterBlock').value = '';
        document.getElementById('filterPlot').value = '';
        this.showAll();
      }

      async loadScheduleFile(file) {
        try {
          const scheduleStatus = document.getElementById('scheduleStatus');
          scheduleStatus.textContent = 'Loading...';
          scheduleStatus.style.color = '#666';
          
          console.log(`üìÖ Loading schedule file: ${file.name}`);
          
          // Parse Excel file
          await dataParser.parseExcelFile(file);
          
          // Update status
          const blockCount = dataParser.scheduleByBlock.size;
          scheduleStatus.textContent = `‚úÖ Loaded ${blockCount} blocks`;
          scheduleStatus.style.color = '#009A84';
          
          console.log(`‚úÖ Schedule loaded: ${blockCount} blocks`);
          
          // Refresh Gantt chart if it exists
          if (window.ganttChart) {
            window.ganttChart.refresh();
          }
          
          // Refresh schedule panel if it exists
          if (window._currentBlockMap) {
            const existing = document.getElementById('permanentSchedulePanel');
            if (existing) {
              existing.remove();
              // Import createSchedulePanel from visual-block-identifier
              const { showInteractiveBlockList } = await import('./js/visual-block-identifier.js');
              const neighborhood = document.getElementById('filterNeighborhood').value;
              if (neighborhood && window._currentBlockMap) {
                // Recreate schedule panel with new data
                window.location.reload(); // Simple refresh for now
              }
            }
          }
          
        } catch (error) {
          console.error('‚ùå Schedule loading error:', error);
          const scheduleStatus = document.getElementById('scheduleStatus');
          scheduleStatus.textContent = '‚ùå Error loading file';
          scheduleStatus.style.color = '#dc3545';
        }
      }

      updateLegend() {
        const legendDiv = document.getElementById('legend');
        if (!legendDiv) return;

        const legendItems = embeddedColorManager.getLegend();

        if (legendItems.length === 0) {
          legendDiv.innerHTML = '';
          return;
        }

        let html = '<div class="legend-container"><h4>Legend</h4>';

        legendItems.forEach(item => {
          const rgbColor = `rgb(${item.color.r}, ${item.color.g}, ${item.color.b})`;
          html += `
            <div class="legend-item">
              <div class="legend-color" style="background: ${rgbColor};"></div>
              <span class="legend-label">${item.label}</span>
              <span class="legend-count">(${item.count})</span>
            </div>
          `;
        });

        html += '</div>';
        legendDiv.innerHTML = html;
      }

      exportData() {
        const data = embeddedDataManager.exportData();
        const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'model-data-export.json';
        a.click();
        URL.revokeObjectURL(url);
        this.updateStatus('Data exported', 'success');
      }

      async debugProperties() {
        console.log('üîç === SEARCHING FOR REVIT ELEMENTS (SMART SEARCH) ===');
        const allDbIds = await viewerManager.getAllDbIds();

        if (allDbIds.length === 0) {
          console.error('No elements found in model');
          return;
        }

        console.log(`Total elements in model: ${allDbIds.length}`);
        console.log('Strategy: Search beginning, middle, and end of model...');

        // Search through DIFFERENT parts of the model (beginning, middle, end)
        let foundRevitElements = [];
        const SAMPLES = [
          { start: 0, count: 500, label: 'Beginning (0-500)' },
          { start: Math.floor(allDbIds.length * 0.25), count: 500, label: 'Quarter (25%)' },
          { start: Math.floor(allDbIds.length * 0.50), count: 500, label: 'Middle (50%)' },
          { start: Math.floor(allDbIds.length * 0.75), count: 500, label: 'Three-Quarter (75%)' },
          { start: Math.max(0, allDbIds.length - 500), count: 500, label: 'End (last 500)' }
        ];

        for (const sample of SAMPLES) {
          console.log(`\nüîé Searching ${sample.label}...`);
          const startIdx = sample.start;
          const endIdx = Math.min(startIdx + sample.count, allDbIds.length);

          for (let i = startIdx; i < endIdx; i++) {
            const dbId = allDbIds[i];
            const props = await viewerManager.getBulkProperties([dbId], null);

            if (props && props.length > 0) {
              const elementProps = props[0].properties;

              // Check if this element has Revit properties OR source file
              const hasRevitProps = elementProps.some(p =>
                p.displayName === 'Element/Block' ||
                p.displayName === 'Element/Plot' ||
                p.displayName === 'Element/Villa_Type'
              );

              const sourceFile = elementProps.find(p => p.displayName === 'Item/Source File' || p.displayName === 'Source File');
              const isRevitFile = sourceFile && sourceFile.displayValue && sourceFile.displayValue.includes('.rvt');

              if (hasRevitProps) {
                foundRevitElements.push(dbId);

                if (foundRevitElements.length <= 5) {
                  console.log(`\n‚úÖ FOUND REVIT ELEMENT ${dbId} in ${sample.label}:`);
                  elementProps
                    .filter(p => p.displayValue && p.displayValue !== '' && p.displayName.includes('Element/'))
                    .forEach(p => {
                      console.log(`  "${p.displayName}" = "${p.displayValue}"`);
                    });

                  const extracted = embeddedDataManager.extractElementInfo(elementProps);
                  console.log('Extracted:', extracted);
                }
              } else if (isRevitFile && i === startIdx) {
                // Show first .rvt file found in each section
                console.log(`  Found .rvt element at dbId ${dbId}: ${sourceFile.displayValue}`);
              }
            }

            // Progress indicator
            if ((i - startIdx) % 100 === 0) {
              console.log(`  Progress: ${i - startIdx}/${sample.count} in ${sample.label}... Found ${foundRevitElements.length} total`);
            }
          }

          if (foundRevitElements.length > 0) {
            console.log(`‚úì Found ${foundRevitElements.length} Revit elements so far!`);
            break; // Stop searching once we find some
          }
        }

        console.log(`\nüìä SEARCH COMPLETE:`);
        console.log(`  Total elements in model: ${allDbIds.length}`);
        console.log(`  Found Revit elements: ${foundRevitElements.length}`);
        console.log(`  Revit element IDs: ${foundRevitElements.slice(0, 10).join(', ')}${foundRevitElements.length > 10 ? '...' : ''}`);

        this.updateStatus(`Found ${foundRevitElements.length} Revit elements - check console`, 'success');

        // If no elements found, try deep search in nested files
        if (foundRevitElements.length === 0) {
          console.log('\nüîç No Revit properties found in top-level search.');
          console.log('Starting DEEP SEARCH in nested Revit files...');
          await this.deepSearchNestedFiles();
        }
      }

      async deepSearchNestedFiles() {
        console.log('\n=== DEEP SEARCH: Checking Known .rvt File Areas ===');

        // We know from earlier search that these .rvt files exist:
        // - dbId 310272: Test power BI_Ali_ElraeiJZDC9.rvt (this is the villa file!)
        // - dbId 176026: 00910-PCM-CIW-BR1-PIM-SE-000001.rvt

        const revitFileDbIds = [310272, 176026];

        for (const fileDbId of revitFileDbIds) {
          console.log(`\nüîé Searching around dbId ${fileDbId}...`);

          // Try elements AFTER this file node (likely where actual elements are)
          const searchRange = 200; // Check 200 elements after the file node
          let foundCount = 0;

          for (let offset = 1; offset <= searchRange && foundCount < 5; offset++) {
            const testDbId = fileDbId + offset;

            try {
              const props = await viewerManager.getBulkProperties([testDbId], null);

              if (props && props.length > 0) {
                const elementProps = props[0].properties;

                // Check source file to see if it's from the villa .rvt
                const sourceFile = elementProps.find(p =>
                  p.displayName === 'Item/Source File' || p.displayName === 'Source File'
                );

                if (sourceFile && sourceFile.displayValue && sourceFile.displayValue.includes('power BI')) {
                  // This element is from the villa file!
                  const hasBlock = elementProps.find(p => p.displayName === 'Element/Block');
                  const hasPlot = elementProps.find(p => p.displayName === 'Element/Plot');
                  const hasVillaType = elementProps.find(p => p.displayName === 'Element/Villa_Type');

                  if (hasBlock || hasPlot || hasVillaType) {
                    console.log(`\n‚úÖ FOUND REVIT ELEMENT! DbId: ${testDbId}`);
                    console.log(`Source: ${sourceFile.displayValue}`);
                    elementProps
                      .filter(p => p.displayValue && p.displayValue !== '' && p.displayName.startsWith('Element/'))
                      .forEach(p => console.log(`  ${p.displayName} = ${p.displayValue}`));

                    const extracted = embeddedDataManager.extractElementInfo(elementProps);
                    console.log('Extracted:', extracted);

                    foundCount++;
                  } else if (offset <= 10) {
                    // Show first 10 villa file elements even without Block/Plot
                    console.log(`  DbId ${testDbId}: From ${sourceFile.displayValue} but no Element/Block or Plot`);

                    // Show ALL properties for first element to see what's available
                    if (offset === 1) {
                      console.log('\nüìã ALL PROPERTIES FOR FIRST VILLA ELEMENT (dbId ' + testDbId + '):');
                      elementProps
                        .filter(p => p.displayValue && p.displayValue !== '')
                        .forEach(p => console.log(`  "${p.displayName}" = "${p.displayValue}"`));
                    }
                  }
                }
              }
            } catch (e) {
              // Element doesn't exist, skip
            }

            if (offset % 50 === 0) {
              console.log(`  Checked ${offset}/${searchRange} elements...`);
            }
          }

          if (foundCount > 0) {
            console.log(`\n‚úì Found ${foundCount} elements with Revit properties near dbId ${fileDbId}!`);
            return; // Success
          }
        }

        console.log('\n‚ùå Deep search complete - properties may be stored differently in this Navisworks file');
        console.log('üí° Searching for LEAF NODES (actual geometry) with properties...');

        await this.searchLeafNodes();
      }

      async searchLeafNodes() {
        console.log('\n=== SEARCHING LEAF NODES (GEOMETRY) ===');

        const instanceTree = viewerManager.viewer.model.getInstanceTree();
        if (!instanceTree) {
          console.error('Instance tree not available');
          return;
        }

        // Collect all leaf nodes (nodes with no children = actual geometry)
        const leafNodes = [];
        const allDbIds = await viewerManager.getAllDbIds();

        console.log(`Checking ${allDbIds.length} nodes for leaf nodes...`);

        for (let i = 0; i < allDbIds.length && leafNodes.length < 500; i++) {
          const dbId = allDbIds[i];

          // Check if this node has children
          let hasChildren = false;
          instanceTree.enumNodeChildren(dbId, () => {
            hasChildren = true;
          });

          if (!hasChildren) {
            leafNodes.push(dbId);
          }

          if (i % 10000 === 0) {
            console.log(`  Scanned ${i}/${allDbIds.length}... Found ${leafNodes.length} leaf nodes`);
          }
        }

        console.log(`\nFound ${leafNodes.length} leaf nodes (actual geometry elements)`);
        console.log(`Checking first 50 leaf nodes for Revit properties...`);

        // Check leaf nodes for properties
        let foundWithProps = 0;
        for (let i = 0; i < Math.min(50, leafNodes.length); i++) {
          const dbId = leafNodes[i];

          try {
            const props = await viewerManager.getBulkProperties([dbId], null);

            if (props && props.length > 0) {
              const elementProps = props[0].properties;

              const hasBlock = elementProps.find(p => p.displayName === 'Element/Block');
              const hasPlot = elementProps.find(p => p.displayName === 'Element/Plot');
              const sourceFile = elementProps.find(p =>
                (p.displayName === 'Item/Source File' || p.displayName === 'Source File') &&
                p.displayValue && p.displayValue.includes('power BI')
              );

              if ((hasBlock || hasPlot) && sourceFile) {
                console.log(`\n‚úÖ FOUND LEAF NODE WITH PROPERTIES! DbId: ${dbId}`);
                elementProps
                  .filter(p => p.displayValue && p.displayValue !== '' && p.displayName.startsWith('Element/'))
                  .forEach(p => console.log(`  ${p.displayName} = ${p.displayValue}`));

                foundWithProps++;
              } else if (sourceFile && foundWithProps === 0 && i < 5) {
                // Show first few villa leaf nodes
                console.log(`  Leaf ${dbId}: From villa file but no Element/Block`);
                const allProps = elementProps.filter(p => p.displayValue && p.displayValue !== '').map(p => p.displayName);
                console.log(`    Available props: ${allProps.slice(0, 10).join(', ')}`);
              }
            }
          } catch (e) {
            // Skip
          }
        }

        if (foundWithProps === 0) {
          console.log('\n‚ùå Leaf nodes also do not contain Element/Block or Element/Plot properties via getBulkProperties()');
          console.log('üîÑ Trying property database search...');
          await this.searchPropertyDatabase();
        } else {
          console.log(`\n‚úÖ Found ${foundWithProps} leaf nodes with Revit properties!`);
        }
      }

      async searchPropertyDatabase() {
        console.log('\n=== SEARCHING PROPERTY DATABASE DIRECTLY ===');

        try {
          // STEP 1: Get all available property names first (sample 100 elements with timeout)
          console.log('üìã Step 1: Sampling property names from 100 elements (10 second timeout)...');
          const allPropertyNames = await viewerManager.getAllPropertyNames(100);

          console.log(`‚úÖ Found ${allPropertyNames.length} unique property names in sample`);

          // Filter for potentially relevant properties
          const relevantProps = allPropertyNames.filter(name =>
            name.includes('Element') ||
            name.includes('Plot') ||
            name.includes('Block') ||
            name.includes('Villa') ||
            name.includes('NBH') ||
            name.includes('Phase') ||
            name.includes('Level')
          );

          if (relevantProps.length > 0) {
            console.log(`\nüìä Found ${relevantProps.length} potentially relevant properties:`);
            relevantProps.forEach(name => console.log(`  - ${name}`));
          } else {
            console.log('\n‚ö†Ô∏è No Element/, Plot, Block, Villa, NBH, Phase, or Level properties found in sample');
            console.log('\nüìã First 30 property names found in model:');
            allPropertyNames.slice(0, 30).forEach(name => console.log(`  - ${name}`));
          }

          // STEP 2: Search for specific Revit property names
          console.log('\nüìã Step 2: Searching for specific Revit properties...');
          const searchTerms = ['Element/Block', 'Element/Plot', 'Element/Villa_Type', 'Element/NBH', 'Plot', 'Block'];

          for (const term of searchTerms) {
            console.log(`\nüîé Searching for "${term}" (max 10 results)...`);
            const results = await viewerManager.searchPropertiesInDb(term, 10);

            if (results.length > 0) {
              console.log(`‚úÖ FOUND ${results.length} elements with "${term}" property!`);
              console.log('Matches:');
              results.forEach(r => {
                console.log(`  DbId ${r.dbId}: ${r.propertyName} = ${r.value}`);
              });

              // If we found properties, update the extraction to use property database
              console.log('\nüéâ SUCCESS! Properties ARE in the model - accessible via property database');
              console.log('üìã The extraction code needs to be updated to use the property database API');
              return;
            } else {
              console.log(`  ‚ùå No matches found for "${term}"`);
            }
          }

          console.log('\n‚ùå Property database search complete - no Revit custom parameters found');
          console.log('üî¥ CRITICAL: The Navisworks translation did NOT preserve Revit custom parameters');
          console.log('\nüìã RECOMMENDED SOLUTIONS:');
          console.log('   1. Re-translate the model with property extraction enabled (see RETRANSLATION_GUIDE.md)');
          console.log('   2. Upload the Revit .rvt file directly instead of the Navisworks .nwd file');
          console.log('   3. Check if properties are named differently (review property list above)');

        } catch (error) {
          console.error('‚ùå Property database search failed:', error.message);
          console.log('üìã Falling back to re-translation solution');
        }
      }

      updateStatus(message, type = 'info') {
        const statusDiv = document.getElementById('status');
        if (statusDiv) {
          statusDiv.textContent = message;
          statusDiv.className = `status status-${type}`;
          console.log(`[${type.toUpperCase()}] ${message}`);
        }
      }

      enableControls() {
        const controls = [
          'colorScheme',
          'showAllBtn',
          'fitViewBtn',
          'exportDataBtn',
          'debugPropsBtn',
          'analyzeBtn',
          'filterPhase',
          'filterNeighborhood',
          'filterBlock',
          'filterPlot',
          'applyFiltersBtn',
          'clearFiltersBtn'
        ];
        controls.forEach(id => {
          const element = document.getElementById(id);
          if (element) element.disabled = false;
        });
      }

      checkAuthStatus() {
        this.isAuthenticated = authManager.isAuthenticated();

        const loginBtn = document.getElementById('loginBtn');
        const logoutBtn = document.getElementById('logoutBtn');
        const loadModelBtn = document.getElementById('loadModelBtn');
        const authStatusText = document.getElementById('authStatusText');

        if (this.isAuthenticated) {
          if (loginBtn) loginBtn.style.display = 'none';
          if (logoutBtn) logoutBtn.style.display = 'inline-block';
          if (loadModelBtn) loadModelBtn.disabled = false;
          if (authStatusText) authStatusText.textContent = '‚úÖ Logged in';
          this.updateStatus('Logged in - Ready to load model', 'success');
        } else {
          if (loginBtn) loginBtn.style.display = 'inline-block';
          if (logoutBtn) logoutBtn.style.display = 'none';
          if (loadModelBtn) loadModelBtn.disabled = true;
          if (authStatusText) authStatusText.textContent = '‚ö†Ô∏è Not logged in';
        }
      }

      handleLogin() {
        authManager.openLoginPopup();
        this.updateStatus('Please complete login in popup...', 'info');
      }

      handleLogout() {
        authManager.logout();
        this.checkAuthStatus();
        this.updateStatus('Logged out', 'info');
        if (this.modelLoaded) {
          this.modelLoaded = false;
          this.dataAnalyzed = false;
          viewerManager.destroy();
        }
      }
    }

    // Initialize dashboard
    const dashboard = new Dashboard();
    document.addEventListener('DOMContentLoaded', () => {
      dashboard.init();
    });

    // Make dashboard accessible globally for debugging
    window.dashboard = dashboard;
    window.embeddedDataManager = embeddedDataManager;
    window.viewerManager = viewerManager;
    window.findExactPropertyNames = findExactPropertyNames;
    window.findVillaElements = findVillaElements;
    window.searchForRealVillas = searchForRealVillas;
    window.exploreModelStructure = exploreModelStructure;
    window.findVillaNodes = findVillaNodes;
    window.exploreInstanceTree = exploreInstanceTree;
    window.exploreFederatedModels = exploreFederatedModels;
    window.exploreDocumentStructure = exploreDocumentStructure;
    window.extractVillaModelData = extractVillaModelData;
    window.findNestedModels = findNestedModels;
    window.checkModelReferences = checkModelReferences;
    window.extractVillaDataFromNode = extractVillaDataFromNode;
    window.debugColorByNeighborhood = debugColorByNeighborhood;
    window.testColoring = testColoring;
    window.showInteractiveBlockList = showInteractiveBlockList;
    window.hideBlockLabels = hideBlockLabels;
    window.diagnosticAnalysis = diagnosticAnalysis;
  </script>

  <!-- Gantt Chart Floating Window -->
  <div id="ganttWindow" class="gantt-window">
    <div class="gantt-header">
      <div class="gantt-title">
        <span>üìä Schedule Gantt Chart</span>
      </div>
      <div class="gantt-controls">
        <button id="ganttMinimize" class="gantt-btn" title="Minimize">‚àí</button>
        <button id="ganttMaximize" class="gantt-btn" title="Maximize">‚ñ°</button>
        <button id="ganttClose" class="gantt-btn" title="Close">√ó</button>
      </div>
    </div>
    <div class="gantt-toolbar">
      <div class="gantt-filter-group">
        <button id="ganttTodayBtn" class="gantt-btn-filter" title="Jump to today's date">üìÖ Today</button>
        <button id="ganttResetTodayBtn" class="gantt-btn-filter" title="Reset Today line to actual date">üîÑ Reset Today</button>
        <label>From:</label>
        <input type="date" id="ganttStartDate" class="gantt-date-input">
        <label>To:</label>
        <input type="date" id="ganttEndDate" class="gantt-date-input">
        <button id="ganttApplyFilter" class="gantt-btn-filter">Apply</button>
        <button id="ganttResetFilter" class="gantt-btn-filter">Reset</button>
      </div>
      <div class="gantt-view-group">
        <label style="display: flex; align-items: center; gap: 4px;">
          <input type="checkbox" id="ganttLookAhead">
          Look Ahead:
          <input type="number" id="ganttLookAheadWeeks" class="gantt-weeks-input" value="12" min="1" max="52" title="Number of weeks">
          <span style="font-size: 11px;">weeks</span>
        </label>
        <label>
          <input type="checkbox" id="ganttShowVillas">
          Show Villas in Chart
        </label>
        <label>
          <input type="checkbox" id="ganttFilterModel">
          Filter Villas in Model
        </label>
      </div>
    </div>
    <div class="gantt-content" id="ganttContent">
      <div class="gantt-timeline" id="ganttTimeline"></div>
      <div class="gantt-tasks" id="ganttTasks"></div>
    </div>
  </div>

  <!-- Gantt Chart Toggle Button -->
  <button id="ganttToggle" class="gantt-toggle-btn" title="Toggle Gantt Chart">
    üìä Schedule
  </button>

  <!-- Import Gantt Chart Module -->
  <script type="module">
    import { ganttChart } from './js/ganttChart.js';
    window.ganttChart = ganttChart;
  </script>

</body>
</html>
