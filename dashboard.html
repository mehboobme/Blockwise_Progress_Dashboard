<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Blockwise Progress Dashboard - Federated Model</title>

  <!-- APS Viewer CSS -->
  <link rel="stylesheet" href="https://developer.api.autodesk.com/modelderivative/v2/viewers/7.*/style.min.css">

  <!-- SheetJS for Excel parsing -->
  <script src="https://cdn.sheetjs.com/xlsx-latest/package/dist/xlsx.full.min.js"></script>

  <!-- Custom CSS -->
  <link rel="stylesheet" href="css/styles.css">
</head>
<body>
  <!-- Header -->
  <header class="app-header">
    <div class="header-left">
      <img src="images/ROSHN Logo_with no text.gif" alt="Roshn Logo" class="header-logo">
      <h1>Construction Progress Dashboard</h1>
    </div>
    <div class="header-actions">
      <div id="authStatus" class="auth-status">
        <span id="authStatusText">Not logged in</span>
        <button id="loginBtn" class="btn btn-success">Login to Autodesk</button>
        <button id="logoutBtn" class="btn btn-secondary" style="display: none;">Logout</button>
      </div>
      <button id="loadModelBtn" class="btn btn-primary" disabled>Load Model</button>
      <!-- Analyze Model button removed - auto-triggered by Load Model -->
      <button id="ganttToggle" class="btn btn-primary" title="Toggle Gantt Chart">üìä Gantt Chart</button>
    </div>
  </header>

  <!-- Main Container -->
  <div class="main-container">

    <!-- Sidebar -->
    <aside class="sidebar">

      <!-- Filters Panel -->
      <div class="panel">
        <h3>üîΩ Filters</h3>

        <div class="control-group">
          <label for="filterPhase">Phase:</label>
          <select id="filterPhase" disabled>
            <option value="">All</option>
          </select>
        </div>

        <div class="control-group">
          <label for="filterNeighborhood">Neighborhood:</label>
          <select id="filterNeighborhood" disabled>
            <option value="">All</option>
          </select>
        </div>

        <div class="control-group">
          <label for="filterBlock">Blocks:</label>
          <select id="filterBlock" disabled>
            <option value="">All</option>
          </select>
        </div>

        <div class="control-group">
          <label for="filterPlot">Plot:</label>
          <input type="text" id="filterPlot" list="plotList" placeholder="Type or select plot..." disabled style="width: 100%; padding: 6px; border: 1px solid #ccc; border-radius: 4px;">
          <datalist id="plotList">
            <option value="">All</option>
          </datalist>
        </div>

        <button id="applyFiltersBtn" class="btn btn-primary btn-full" disabled>Apply Filters</button>
        <button id="clearFiltersBtn" class="btn btn-secondary btn-full" disabled>Include Infra</button>
        <button id="clearAllBtn" class="btn btn-secondary btn-full">Clear All</button>
        <button id="showAllBtn" class="btn btn-secondary btn-full" disabled>Show All</button>
        <button id="resetBtn" class="btn btn-warning btn-full">Reset</button>
      </div>

      <!-- Controls Panel -->
      <div class="panel">
        <h3>üé® Visualization</h3>
        <div class="control-group">
          <label for="colorScheme">Color Scheme:</label>
          <select id="colorScheme" disabled>
            <option value="None">None</option>
            <option value="Block" selected>By Block</option>
            <option value="Status">By Status</option>
          </select>
        </div>
      </div>

      <!-- Schedule Data Panel -->
      <div class="panel">
        <h3>üìÖ Schedule Data</h3>
        <div class="control-group">
          <label for="scheduleFileInput" style="font-size: 12px; color: #666;">Upload Excel File:</label>
          <input type="file" id="scheduleFileInput" accept=".xlsx,.xls" style="display: none;">
          <button id="uploadScheduleBtn" class="btn btn-primary btn-full">Upload Schedule</button>
          <div id="scheduleStatus" style="margin-top: 8px; font-size: 11px; color: #666;"></div>
        </div>
      </div>

      <!-- Dynamic Legends Panel -->
      <div class="panel legends-panel" id="legendsPanel" style="display: none;">
        <h3>üìä Legends</h3>
        
        <!-- Construction Status Legend -->
        <div class="legend-section">
          <h4>Construction Status (ref villa color)</h4>
          <div class="legend-item"><span class="legend-color" style="background: #0066FF;"></span>Raft Completed</div>
          <div class="legend-item"><span class="legend-color" style="background: #66FFFF;"></span>Pre-Cast in Progress</div>
          <div class="legend-item"><span class="legend-color" style="background: #CCCC00;"></span>Pre-Cast Completed</div>
          <div class="legend-item"><span class="legend-color" style="background: #FF66CC;"></span>MEP & Finishes in Progress</div>
          <div class="legend-item"><span class="legend-color" style="background: #66FF33;"></span>MEP & Finishes Completed</div>
          <div class="legend-item"><span class="legend-color" style="background: #339966;"></span>Villa Handover</div>
        </div>
        
        <!-- Contractors Legend -->
        <div class="legend-section">
          <h4>Contractors (ref block# labels color)</h4>
          <div class="legend-item"><span class="legend-color" style="background: #66B3FF;"></span>SPML (Light Blue)</div>
          <div class="legend-item"><span class="legend-color" style="background: #FFD700;"></span>ABR (Golden)</div>
        </div>
        
        <!-- Precasters Legend -->
        <div class="legend-section">
          <h4>Precasters</h4>
          <div class="legend-item"><span class="legend-badge">Q</span>Qanbar</div>
          <div class="legend-item"><span class="legend-badge">P</span>Premco</div>
          <div class="legend-item"><span class="legend-badge">S</span>Sald</div>
          <div class="legend-item"><span class="legend-badge">M</span>MGB</div>
        </div>
      </div>

      <!-- Stats -->
      <div class="panel" id="stats">
        <!-- Stats will be populated dynamically -->
      </div>

    </aside>

    <!-- Viewer Container -->
    <main class="viewer-section">
      <div id="viewerContainer" class="viewer-container"></div>
      <div id="status" class="status">Ready - Login and load model to begin</div>
    </main>

  </div>

  <!-- APS Viewer JS -->
  <script src="https://developer.api.autodesk.com/modelderivative/v2/viewers/7.*/viewer3D.min.js"></script>

  <!-- Dashboard script -->
  <script type="module">
    import { CONFIG } from './js/config.js';
    import { viewerManager } from './js/viewer.js';
    import { embeddedDataManager } from './js/embeddedDataManager.js';
    import { embeddedColorManager } from './js/embeddedColorManager.js';
    import { authManager } from './js/auth.js';
    import { propertyPanel } from './js/propertyPanel.js';
    import { analyzePlotDistribution } from './js/plot-number-analysis.js';
    import { diagnosticAnalysis } from './js/diagnostic-property-analysis.js';
    import { findExactPropertyNames } from './js/find-exact-property-names.js';
    import { findVillaElements } from './js/find-villa-elements.js';
    import { searchForRealVillas } from './js/search-real-villas.js';
    import { exploreModelStructure } from './js/explore-model-structure.js';
    import { findVillaNodes } from './js/find-villa-nodes.js';
    import { exploreInstanceTree } from './js/explore-instance-tree.js';
    import { exploreFederatedModels } from './js/explore-federated-models.js';
    import { exploreDocumentStructure, extractVillaModelData } from './js/explore-document-structure.js';
    import { findNestedModels, checkModelReferences } from './js/find-nested-models.js';
    import { extractVillaDataFromNode } from './js/extract-villa-node-data.js';
    import { debugColorByNeighborhood } from './js/debug-color-neighborhood.js';
    import { testColoring } from './js/test-coloring.js';
    import { showInteractiveBlockList, hideBlockLabels } from './js/visual-block-identifier.js';
    import { debugBlockLabelSystem, testSingleLabel, fixPanelPosition } from './js/debug-block-labels.js';
    import { ganttChart } from './js/ganttChart.js';
    import { dataParser } from './js/dataParser.js';

    // Expose managers to window for ganttChart.js access
    window.embeddedColorManager = embeddedColorManager;
    window.embeddedDataManager = embeddedDataManager;
    window.viewerManager = viewerManager;

    class Dashboard {
      constructor() {
        this.modelLoaded = false;
        this.dataAnalyzed = false;
        this.isAuthenticated = false;
      }

      async init() {
        console.log('üöÄ Initializing dashboard...');

        // Initialize auth
        authManager.initLoginListener();

        // Initialize property panel
        propertyPanel.initialize();

        // Setup UI listeners
        this.setupUIListeners();

        // Setup viewer callbacks
        this.setupViewerCallbacks();

        // Check auth status
        this.checkAuthStatus();

        console.log('‚úÖ Dashboard initialized');
      }

      setupUIListeners() {
        // Login/Logout
        document.getElementById('loginBtn')?.addEventListener('click', () => this.handleLogin());
        document.getElementById('logoutBtn')?.addEventListener('click', () => this.handleLogout());

        // Load model
        document.getElementById('loadModelBtn')?.addEventListener('click', () => this.loadModel());

        // Analyze model
        document.getElementById('analyzeBtn')?.addEventListener('click', () => this.analyzeModel());

        // Filters
        document.getElementById('applyFiltersBtn')?.addEventListener('click', () => this.applyFilters());
        document.getElementById('clearFiltersBtn')?.addEventListener('click', () => this.clearFilters());
        document.getElementById('clearAllBtn')?.addEventListener('click', () => this.clearAll());
        document.getElementById('resetBtn')?.addEventListener('click', () => this.resetEverything());
        
        // Schedule upload
        document.getElementById('uploadScheduleBtn')?.addEventListener('click', () => {
          document.getElementById('scheduleFileInput').click();
        });
        
        document.getElementById('scheduleFileInput')?.addEventListener('change', async (e) => {
          const file = e.target.files[0];
          if (file) {
            await this.loadScheduleFile(file);
          }
        });

        // Color scheme
        document.getElementById('colorScheme')?.addEventListener('change', (e) => {
          if (this.dataAnalyzed) {
            this.applyColorScheme(e.target.value);
          } else {
            this.updateStatus('Please wait for model analysis to complete', 'warning');
          }
        });

        // Show all
        document.getElementById('showAllBtn')?.addEventListener('click', () => this.showAll());

        // Fit to view
        document.getElementById('fitViewBtn')?.addEventListener('click', () => viewerManager.fitToView());

        // Export data
        document.getElementById('exportDataBtn')?.addEventListener('click', () => this.exportData());

        // Gantt chart toggle - wait for module to load
        document.getElementById('ganttToggle')?.addEventListener('click', async () => {
          console.log('üìä Gantt toggle clicked');
          
          // Close Block List and Schedule panels when opening Gantt
          const blockPanel = document.getElementById('blockInfoPanel');
          if (blockPanel) blockPanel.remove();
          
          const schedulePanel = document.getElementById('permanentSchedulePanel');
          if (schedulePanel) schedulePanel.remove();

          // Wait for ganttChart to be available
          let attempts = 0;
          while (!window.ganttChart && attempts < 10) {
            console.log('‚è≥ Waiting for ganttChart module...');
            await new Promise(resolve => setTimeout(resolve, 100));
            attempts++;
          }

          if (window.ganttChart) {
            console.log('‚úÖ ganttChart exists, calling toggleWindow');
            window.ganttChart.toggleWindow();
          } else {
            console.error('‚ùå window.ganttChart not found after waiting');
            alert('Gantt chart module not loaded. Please refresh the page.');
          }
        });

        // Auth success message
        window.addEventListener('message', (event) => {
          if (event.data.type === 'auth_success') {
            this.checkAuthStatus();
          }
        });
      }

      setupViewerCallbacks() {
        viewerManager.onSelectionChanged = async (dbIds) => {
          if (dbIds.length > 0) {
            // await this.showElementProperties(dbIds[0]);
          } else {
            // propertyPanel.hide();
          }
        };

        viewerManager.onGeometryLoaded = async () => {
          console.log('üìê Geometry loaded');
          this.updateStatus('Model loaded - Auto-analyzing...', 'info');
          // Auto-analyze model after geometry loads
          await this.analyzeModel();
        };
      }

      async loadModel() {
        try {
          this.updateStatus('Loading model (311k elements - this may take 1-2 minutes)...', 'info');

          // Initialize viewer
          await viewerManager.initialize(CONFIG.VIEWER.container);

          // Add progress tracking for large model
          let progressInterval = setInterval(() => {
            console.log('‚è≥ Large model loading in progress...');
          }, 5000);

          // Determine model identifier - auto-fetch latest or use fallback
          let identifier = CONFIG.MODEL_URN;
          let versionInfo = null;
          
          if (CONFIG.AUTO_FETCH_LATEST_VERSION) {
            console.log('üîÑ Auto-fetching latest model version from ACC...');
            console.log('   Server URL:', CONFIG.SERVER_URL);
            this.updateStatus('Fetching latest model version from ACC...', 'info');
            
            try {
              const sessionId = localStorage.getItem('aps_session_id');
              console.log('   Session ID:', sessionId ? sessionId.substring(0, 20) + '...' : 'NONE');
              
              const response = await fetch(`${CONFIG.SERVER_URL}/api/acc/latest-model?sessionId=${sessionId}`);
              console.log('   Response status:', response.status);
              
              const data = await response.json();
              console.log('   Response data:', data);
              
              if (data.success) {
                identifier = data.base64Urn;
                versionInfo = {
                  version: data.versionNumber,
                  fileName: data.fileName
                };
                console.log(`‚úÖ Auto-fetched latest version: ${data.fileName} v${data.versionNumber}`);
                console.log('   URN:', identifier.substring(0, 50) + '...');
                this.updateStatus(`Loading ${data.fileName} (v${data.versionNumber})...`, 'info');
              } else {
                console.warn('‚ö†Ô∏è Could not fetch latest version, using fallback URN');
                console.warn('   Reason:', data.message || data.error);
                console.warn('   Full response:', JSON.stringify(data));
                
                // If auth error, prompt user to re-login
                if (response.status === 401) {
                  this.updateStatus('Session expired - Please click Login button again, then Load Model', 'warning');
                  alert('Your session has expired (server may have restarted).\n\nPlease:\n1. Click the "Login" button\n2. Complete Autodesk login\n3. Then click "Load Model" again');
                }
              }
            } catch (fetchError) {
              console.error('‚ùå Auto-fetch failed:', fetchError);
              console.warn('‚ö†Ô∏è Using fallback URN');
            }
          }
          
          if (!identifier) {
            clearInterval(progressInterval);
            throw new Error('No MODEL_URN in config.js and auto-fetch failed');
          }

          console.log('Loading large model (311k elements)...');
          await viewerManager.loadModel(identifier);

          clearInterval(progressInterval);

          this.modelLoaded = true;
          
          // Store version info for display
          if (versionInfo) {
            window._currentModelVersion = versionInfo;
          }
          
          console.log('‚úÖ Model load complete, instance tree:', viewerManager.instanceTree);
          this.updateStatus('Model loaded - Analyzing...', 'info');

          // Enable basic controls
          this.enableControls();
          
          // Auto-trigger analysis
          await this.analyzeModel();

        } catch (error) {
          console.error('‚ùå Model load error:', error);
          this.updateStatus('Failed to load model: ' + error.message, 'error');
        }
      }

      async analyzeModel() {
        if (!this.modelLoaded) {
          this.updateStatus('Load model first', 'warning');
          return;
        }

        // Check if viewer has instance tree
        if (!viewerManager.instanceTree) {
          console.warn('‚ö†Ô∏è Instance tree not ready yet, waiting 2 more seconds...');
          this.updateStatus('Waiting for model to be ready...', 'info');
          setTimeout(() => this.analyzeModel(), 2000);
          return;
        }

        try {
          this.updateStatus('üîç Starting analysis - Extracting villa elements...', 'info');
          console.log('üîç Starting model analysis...');

          // Show progress immediately
          let lastUpdate = Date.now();
          const progressCallback = (progress, message) => {
            // Throttle updates to every 500ms to avoid overwhelming the UI
            const now = Date.now();
            if (now - lastUpdate > 500) {
              this.updateStatus(`üìä ${message} - ${progress}% complete`, 'info');
              lastUpdate = now;
            }
          };

          const stats = await embeddedDataManager.analyzeModel(progressCallback);

          this.dataAnalyzed = true;
          console.log('‚úÖ Analysis complete:', stats);
          this.updateStatus(`‚úÖ Analysis complete: ${stats.phases} phases, ${stats.neighborhoods} neighborhoods, ${stats.blocks} construction activities, ${stats.plots} plots`, 'success');

          // Populate filter dropdowns
          this.populateFilters();
          console.log('‚úÖ Filters populated');

          // Display stats
          this.displayStats(stats);

          // Auto-apply color scheme
          if (CONFIG.UI.AUTO_COLOR_BY) {
            await this.applyColorScheme(CONFIG.UI.AUTO_COLOR_BY);
          }
          
          // Initialize proper zoom by applying a filter then clearing it
          // This replicates: user applies filter -> clicks Clear All -> zoom works
          setTimeout(() => {
            this.initializeZoom();
          }, 1000);

        } catch (error) {
          console.error('‚ùå Analysis error:', error);
          this.updateStatus('Failed to analyze model: ' + error.message, 'error');
        }
      }
      
      initializeZoom() {
        console.log('üéØ Initializing zoom behavior...');
        
        // Get first available block to use as temporary filter
        const blocks = embeddedDataManager.getAllBlocks();
        if (blocks && blocks.length > 0) {
          const firstBlock = blocks[0];
          const dbIds = embeddedDataManager.getElementsByBlock(firstBlock);
          
          if (dbIds && dbIds.length > 0) {
            // Apply filter (this calls isolate + fitToView)
            viewerManager.isolate(dbIds);
            viewerManager.fitToView(dbIds);
            
            // Then immediately clear to show all (this preserves the zoom initialization)
            setTimeout(() => {
              this.clearAll();
              console.log('‚úÖ Zoom initialized - model ready for proper zoom behavior');
            }, 100);
          }
        }
      }

      async applyColorScheme(scheme) {
        if (!this.dataAnalyzed) {
          this.updateStatus('Waiting for model analysis to complete...', 'warning');
          return;
        }

        if (scheme === 'None') {
          viewerManager.clearColors();
          this.updateStatus('Colors cleared', 'info');
          return;
        }

        try {
          this.updateStatus(`Applying ${scheme} color scheme...`, 'info');

          await embeddedColorManager.applyColorScheme(scheme);

          this.updateStatus(`${scheme} colors applied`, 'success');

          // Update legend and show legends panel
          this.updateLegend();
          this.updateLegendsPanel(scheme);

          // Check if ANY filter is active and reapply precaster label filter
          let activeFilter = false;
          let visiblePlots = [];
          
          // Check 1: Gantt filter active AND Gantt chart is visible?
          const ganttWindow = document.querySelector('.gantt-window.visible');
          if (ganttWindow && window.ganttChart && window.ganttChart.filteredData && window.ganttChart.filteredData.size > 0) {
            console.log('üîÑ Gantt filter active (chart visible), extracting visible plots...');
            activeFilter = true;
            
            // Get visible plots from Gantt filtered data
            for (const [blockKey, blockData] of window.ganttChart.filteredData) {
              const blockVillas = window.ganttChart.villaData.filter(row => {
                const blockNum = String(row.Block || row.block).trim();
                return blockNum === blockKey;
              });
              blockVillas.forEach(villa => {
                const plotNum = String(villa.Plot || villa.plot).trim();
                visiblePlots.push(plotNum);
              });
            }
          }
          // Check 2: Sidebar filter active?
          else {
            const phase = document.getElementById('filterPhase').value;
            const neighborhood = document.getElementById('filterNeighborhood').value;
            const block = document.getElementById('filterBlock').value;
            const plot = document.getElementById('filterPlot').value;
            
            if (phase || neighborhood || block || plot) {
              console.log('üîÑ Sidebar filter active, extracting visible plots...');
              activeFilter = true;
              
              // Get filtered DBIds based on sidebar filters
              let filteredDbIds = [];
              if (plot) {
                filteredDbIds = embeddedDataManager.getElementsByPlot(plot);
                visiblePlots = [plot];
              } else if (block) {
                filteredDbIds = embeddedDataManager.getElementsByBlock(block);
              } else if (neighborhood) {
                filteredDbIds = embeddedDataManager.getElementsByNeighborhood(neighborhood);
              } else if (phase) {
                filteredDbIds = embeddedDataManager.getElementsByPhase(phase);
              }
              
              // Extract plot numbers from filtered DBIds (unless we already have them)
              if (visiblePlots.length === 0 && filteredDbIds.length > 0) {
                const allPlots = embeddedDataManager.getAllPlots();
                visiblePlots = allPlots.filter(p => {
                  const plotDbIds = embeddedDataManager.getElementsByPlot(p);
                  return plotDbIds.some(id => filteredDbIds.includes(id));
                });
              }
            }
          }
          
          // Apply filter if any filter is active
          if (activeFilter && visiblePlots.length > 0) {
            console.log(`   Filtering precaster labels to ${visiblePlots.length} visible plots`);
            console.log(`   Sample plots: ${visiblePlots.slice(0, 5).join(', ')}`);
            embeddedColorManager.filterPrecasterLabels(visiblePlots);
            console.log('   ‚úÖ Precaster filter applied');
          } else {
            console.log('‚ÑπÔ∏è No active filter, showing all precaster labels');
          }

        } catch (error) {
          console.error('‚ùå Color scheme error:', error);
          this.updateStatus('Failed to apply colors: ' + error.message, 'error');
        }
      }

      colorByNeighborhood(selectedNeighborhood, filteredDbIds) {
        // Color blocks in selected neighborhood with different colors
        
        // Normalize neighborhood name to lowercase (to match stored keys)
        const normalizedNeighborhood = String(selectedNeighborhood).trim().toLowerCase();
        
        console.log(`üé® Coloring blocks in neighborhood ${normalizedNeighborhood}...`);

        // Large color palette with very distinct colors for blocks
        const colorPalette = [
          { r: 255, g: 0, b: 0 },       // Red
          { r: 0, g: 255, b: 0 },       // Green
          { r: 0, g: 0, b: 255 },       // Blue
          { r: 255, g: 255, b: 0 },     // Yellow
          { r: 255, g: 0, b: 255 },     // Magenta
          { r: 0, g: 255, b: 255 },     // Cyan
          { r: 255, g: 165, b: 0 },     // Orange
          { r: 128, g: 0, b: 128 },     // Purple
          { r: 0, g: 128, b: 128 },     // Teal
          { r: 255, g: 192, b: 203 },   // Pink
          { r: 165, g: 42, b: 42 },     // Brown
          { r: 128, g: 128, b: 0 },     // Olive
          { r: 0, g: 128, b: 0 },       // Dark Green
          { r: 128, g: 128, b: 128 },   // Gray
          { r: 255, g: 128, b: 0 },     // Dark Orange
          { r: 0, g: 255, b: 127 },     // Spring Green
          { r: 255, g: 0, b: 127 },     // Crimson
          { r: 127, g: 0, b: 255 },     // Electric Violet
          { r: 0, g: 127, b: 255 },     // Sky Blue
          { r: 255, g: 215, b: 0 },     // Gold
          { r: 100, g: 149, b: 237 },   // Cornflower Blue
          { r: 34, g: 139, b: 34 },     // Forest Green
          { r: 220, g: 20, b: 60 },     // Crimson Red
          { r: 0, g: 206, b: 209 },     // Dark Turquoise
          { r: 184, g: 134, b: 11 },    // Dark Goldenrod
          { r: 139, g: 69, b: 19 },     // Saddle Brown
          { r: 30, g: 144, b: 255 },    // Dodger Blue
          { r: 50, g: 205, b: 50 },     // Lime Green
          { r: 178, g: 34, b: 34 },     // Firebrick
          { r: 72, g: 209, b: 204 },    // Medium Turquoise
          { r: 255, g: 69, b: 0 },      // Red Orange
          { r: 46, g: 125, b: 50 },     // Material Green
          { r: 25, g: 103, b: 210 },    // Material Blue
          { r: 230, g: 124, b: 115 },   // Material Red
          { r: 76, g: 175, b: 80 },     // Material Light Green
          { r: 33, g: 150, b: 243 },    // Material Light Blue
          { r: 244, g: 67, b: 54 }      // Material Red Bright
        ];

        // Group DbIds by block
        const blockToDbIds = new Map();
        
        for (const dbId of filteredDbIds) {
          const elementInfo = embeddedDataManager.elementData.get(dbId);
          
          if (elementInfo) {
            // Normalize both values for comparison (sector from data is uppercase, normalizedNeighborhood is lowercase)
            const elementSectorNormalized = String(elementInfo.sector).trim().toLowerCase();
            
            if (elementSectorNormalized === normalizedNeighborhood) {
              const block = elementInfo.block;
              
              if (block) {
                if (!blockToDbIds.has(block)) {
                  blockToDbIds.set(block, []);
                }
                blockToDbIds.get(block).push(dbId);
              }
            }
          }
        }

        // Sort blocks numerically for consistent color assignment
        const sortedBlocks = Array.from(blockToDbIds.keys()).sort((a, b) => {
          const numA = parseInt(a) || 0;
          const numB = parseInt(b) || 0;
          return numA - numB;
        });

        // Apply different color to each block (in sorted order for consistency)
        let totalColored = 0;
        
        for (let i = 0; i < sortedBlocks.length; i++) {
          const block = sortedBlocks[i];
          const dbIds = blockToDbIds.get(block);
          
          // Assign color based on block index
          const color = colorPalette[i % colorPalette.length];
          color.a = 0.8;  // Add transparency
          
          viewerManager.setColor(dbIds, color);
          totalColored += dbIds.length;
          
          console.log(`  Block ${block}: ${dbIds.length} elements colored with RGB(${color.r},${color.g},${color.b})`);
        }

        console.log(`‚úÖ Colored ${totalColored} elements in ${blockToDbIds.size} blocks`);
      }

      async search(query) {
        if (!query || !this.dataAnalyzed) return;

        try {
          const plotNumber = query.trim();
          const dbIds = embeddedDataManager.getElementsByPlot(plotNumber);

          if (dbIds.length > 0) {
            viewerManager.isolate(dbIds);
            viewerManager.fitToView(dbIds);
            viewerManager.select(dbIds);
            this.updateStatus(`Found ${dbIds.length} elements for plot ${plotNumber}`, 'success');
          } else {
            this.updateStatus(`No elements found for plot ${plotNumber}`, 'warning');
          }

        } catch (error) {
          console.error('‚ùå Search error:', error);
          this.updateStatus('Search failed: ' + error.message, 'error');
        }
      }

      async showAll() {
        viewerManager.showAll();
        viewerManager.clearSelection();
        
        // Close Block List and Schedule panels (but NOT the label container)
        const blockPanel = document.getElementById('blockInfoPanel');
        if (blockPanel) {
          blockPanel.remove();
          console.log('üóëÔ∏è Removed Block List panel');
        }
        
        const schedulePanel = document.getElementById('permanentSchedulePanel');
        if (schedulePanel) {
          schedulePanel.remove();
          console.log('üóëÔ∏è Removed Schedule panel');
        }
        
        // Get current color scheme BEFORE any changes
        const colorScheme = document.getElementById('colorScheme');
        const currentScheme = colorScheme ? colorScheme.value : 'Status';
        
        // If scheme is None or empty, default to Status for Show All
        const schemeToApply = (currentScheme === 'None' || !currentScheme) ? 'Status' : currentScheme;
        
        console.log(`üéØ Show All: restoring ${schemeToApply} color scheme with block labels`);
        
        // Set the dropdown value
        if (colorScheme) {
          colorScheme.value = schemeToApply;
        }
        
        // Reapply color scheme
        await this.applyColorScheme(schemeToApply);
        
        // Wait a bit for color scheme to apply before creating labels
        await new Promise(resolve => setTimeout(resolve, 100));
        
        // Create block labels for all visible blocks
        if (window.embeddedDataManager) {
          const allPlots = embeddedDataManager.getAllPlots();
          const allDbIds = [];
          
          // Collect all DBIds
          allPlots.forEach(plot => {
            const dbIds = embeddedDataManager.getElementsByPlot(plot);
            allDbIds.push(...dbIds);
          });
          
          console.log(`üìã Creating block labels for ${allDbIds.length} elements`);
          
          // Create block labels using the helper function
          this.createBlockLabelsForElements(allDbIds, 'Show All');
        }
        
        this.updateStatus('Showing all elements with status colors, block labels and infrastructure', 'success');
      }

      async showElementProperties(dbId) {
        const elementData = embeddedDataManager.getElementData(dbId);

        if (!elementData) {
          propertyPanel.showNoData(dbId);
          return;
        }

        // Get full model properties
        const modelProps = await viewerManager.getProperties(dbId);

        // Create display data
        const displayData = [{
          project: elementData.project || 'N/A',
          phase: elementData.phase || 'N/A',
          block: elementData.block || 'N/A',
          plot: elementData.plot || 'N/A',
          villa: elementData.villa || 'N/A',
          component: elementData.component || 'N/A',
          plannedStart: elementData.plannedStart,
          plannedFinish: elementData.plannedFinish,
          completionDate: elementData.completionDate
        }];

        propertyPanel.renderProperties(displayData, modelProps);
        propertyPanel.panel.classList.add('visible');
      }

      displayStats(stats) {
        const statsDiv = document.getElementById('stats');
        if (!statsDiv) return;

        const overallStats = embeddedDataManager.getStats();
        
        // Calculate construction status breakdown
        const statusCounts = this.getConstructionStatusCounts();
        const totalVillas = statusCounts.total;
        
        // Get model version info if available
        const versionInfo = window._currentModelVersion;
        const versionDisplay = versionInfo 
          ? `<p style="font-size: 10px; color: #666; margin-top: 5px;">üìÑ ${versionInfo.fileName} (v${versionInfo.version})</p>`
          : '';

        statsDiv.innerHTML = `
          <div class="stats-card">
            <h4>üìä Model Statistics</h4>
            ${versionDisplay}
            <p>Total Elements: ${stats.totalElements}</p>
            <p>Analyzed: ${stats.analyzed} (${stats.analysisRate}%)</p>
            <hr>
            <p>Phases: ${stats.phases}</p>
            <p>Neighborhoods: ${stats.neighborhoods}</p>
            <p>Construction Activities: ${stats.blocks}</p>
            <p>Plots: ${stats.plots}</p>
            <p>Components: ${stats.components}</p>
            <hr>
            <h4>üèóÔ∏è Construction Status</h4>
            <div style="margin: 10px 0; text-align: center;">
              <canvas id="statusPieChart" width="200" height="200"></canvas>
            </div>
            <div style="font-size: 11px; line-height: 1.8; padding: 5px;">
              <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 2px;">
                <span><span style="color: #0066FF; font-size: 14px;">‚¨§</span> Raft:</span>
                <span><strong>${statusCounts.raft}</strong> <span style="opacity: 0.7;">(${statusCounts.raftPct}%)</span></span>
              </div>
              <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 2px;">
                <span><span style="color: #66FFFF; font-size: 14px;">‚¨§</span> Pre-Cast IP:</span>
                <span><strong>${statusCounts.precastIP}</strong> <span style="opacity: 0.7;">(${statusCounts.precastIPPct}%)</span></span>
              </div>
              <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 2px;">
                <span><span style="color: #CCCC00; font-size: 14px;">‚¨§</span> Pre-Cast Done:</span>
                <span><strong>${statusCounts.precastDone}</strong> <span style="opacity: 0.7;">(${statusCounts.precastDonePct}%)</span></span>
              </div>
              <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 2px;">
                <span><span style="color: #FF66CC; font-size: 14px;">‚¨§</span> MEP IP:</span>
                <span><strong>${statusCounts.mepIP}</strong> <span style="opacity: 0.7;">(${statusCounts.mepIPPct}%)</span></span>
              </div>
              <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 2px;">
                <span><span style="color: #66FF33; font-size: 14px;">‚¨§</span> MEP Done:</span>
                <span><strong>${statusCounts.mepDone}</strong> <span style="opacity: 0.7;">(${statusCounts.mepDonePct}%)</span></span>
              </div>
              <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 2px;">
                <span><span style="color: #339966; font-size: 14px;">‚¨§</span> Handover:</span>
                <span><strong>${statusCounts.handover}</strong> <span style="opacity: 0.7;">(${statusCounts.handoverPct}%)</span></span>
              </div>
            </div>
            <p style="margin-top: 10px;"><strong>Total Villas: ${totalVillas}</strong></p>
          </div>
        `;
        
        // Draw pie chart
        this.drawStatusPieChart(statusCounts);
      }
      
      getConstructionStatusCounts() {
        const counts = {
          raft: 0,
          precastIP: 0,
          precastDone: 0,
          mepIP: 0,
          mepDone: 0,
          handover: 0,
          total: 0
        };
        
        if (!window.embeddedDataManager) return counts;
        
        const allPlots = embeddedDataManager.getAllPlots();
        allPlots.forEach(plot => {
          // Get status from Excel data if available
          const excelData = embeddedDataManager.excelData.get(plot);
          if (excelData && excelData.status) {
            counts.total++;
            const status = excelData.status.toLowerCase();
            
            if (status.includes('raft')) counts.raft++;
            else if (status.includes('pre') && status.includes('progress')) counts.precastIP++;
            else if (status.includes('pre') && status.includes('complet')) counts.precastDone++;
            else if (status.includes('mep') && status.includes('progress')) counts.mepIP++;
            else if (status.includes('mep') && status.includes('complet')) counts.mepDone++;
            else if (status.includes('handover')) counts.handover++;
          }
        });
        
        // Calculate percentages
        counts.raftPct = counts.total > 0 ? Math.round((counts.raft / counts.total) * 100) : 0;
        counts.precastIPPct = counts.total > 0 ? Math.round((counts.precastIP / counts.total) * 100) : 0;
        counts.precastDonePct = counts.total > 0 ? Math.round((counts.precastDone / counts.total) * 100) : 0;
        counts.mepIPPct = counts.total > 0 ? Math.round((counts.mepIP / counts.total) * 100) : 0;
        counts.mepDonePct = counts.total > 0 ? Math.round((counts.mepDone / counts.total) * 100) : 0;
        counts.handoverPct = counts.total > 0 ? Math.round((counts.handover / counts.total) * 100) : 0;
        
        return counts;
      }
      
      drawStatusPieChart(counts) {
        const canvas = document.getElementById('statusPieChart');
        if (!canvas) return;
        
        const ctx = canvas.getContext('2d');
        const centerX = 100;
        const centerY = 100;
        const radius = 80;
        
        const data = [
          { value: counts.raft, color: '#0066FF', pct: counts.raftPct, label: 'Raft Completed', status: 'raft' },
          { value: counts.precastIP, color: '#66FFFF', pct: counts.precastIPPct, label: 'Pre-Cast IP', status: 'pre.*progress' },
          { value: counts.precastDone, color: '#CCCC00', pct: counts.precastDonePct, label: 'Pre-Cast Done', status: 'pre.*complet' },
          { value: counts.mepIP, color: '#FF66CC', pct: counts.mepIPPct, label: 'MEP IP', status: 'mep.*progress' },
          { value: counts.mepDone, color: '#66FF33', pct: counts.mepDonePct, label: 'MEP Done', status: 'mep.*complet' },
          { value: counts.handover, color: '#339966', pct: counts.handoverPct, label: 'Handover', status: 'handover' }
        ];
        
        const total = counts.total;
        if (total === 0) return;
        
        let currentAngle = -Math.PI / 2; // Start at top
        const sliceData = []; // Store slice data for click detection
        
        data.forEach(item => {
          if (item.value === 0) return;
          
          const sliceAngle = (item.value / total) * 2 * Math.PI;
          
          // Draw slice
          ctx.beginPath();
          ctx.moveTo(centerX, centerY);
          ctx.arc(centerX, centerY, radius, currentAngle, currentAngle + sliceAngle);
          ctx.closePath();
          ctx.fillStyle = item.color;
          ctx.fill();
          ctx.strokeStyle = '#fff';
          ctx.lineWidth = 2;
          ctx.stroke();
          
          // Draw percentage text inside slice
          if (item.pct >= 5) { // Only show text if slice is big enough
            const textAngle = currentAngle + sliceAngle / 2;
            const textX = centerX + (radius * 0.6) * Math.cos(textAngle);
            const textY = centerY + (radius * 0.6) * Math.sin(textAngle);
            
            ctx.fillStyle = '#000';
            ctx.font = 'bold 12px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(`${item.pct}%`, textX, textY);
          }
          
          // Store slice data for click detection
          sliceData.push({
            startAngle: currentAngle,
            endAngle: currentAngle + sliceAngle,
            label: item.label,
            status: item.status,
            color: item.color
          });
          
          currentAngle += sliceAngle;
        });
        
        // Add click event listener to canvas
        canvas.onclick = (event) => {
          const rect = canvas.getBoundingClientRect();
          const x = event.clientX - rect.left;
          const y = event.clientY - rect.top;
          
          // Convert to canvas coordinates
          const canvasX = x * (canvas.width / rect.width);
          const canvasY = y * (canvas.height / rect.height);
          
          // Calculate angle and distance from center
          const dx = canvasX - centerX;
          const dy = canvasY - centerY;
          const distance = Math.sqrt(dx * dx + dy * dy);
          
          if (distance <= radius) {
            let angle = Math.atan2(dy, dx);
            // Adjust angle to match pie chart rotation (start at top)
            angle = angle + Math.PI / 2;
            if (angle < 0) angle += 2 * Math.PI;
            
            // Find which slice was clicked
            for (const slice of sliceData) {
              let startAngle = slice.startAngle;
              let endAngle = slice.endAngle;
              
              // Normalize angles
              if (startAngle < 0) startAngle += 2 * Math.PI;
              if (endAngle < 0) endAngle += 2 * Math.PI;
              
              if (angle >= startAngle && angle <= endAngle) {
                console.log(`üëÜ Clicked on ${slice.label}`);
                // Call immediately for fast response
                this.filterByConstructionStatus(slice.status, slice.label);
                break;
              }
            }
          }
        };
        
        // Add hover cursor
        canvas.style.cursor = 'pointer';
      }
      
      async filterByConstructionStatus(statusPattern, label) {
        console.log(`üîç Filtering villas by construction status: ${label}`);
        
        const filteredDbIds = [];
        const filteredPlots = [];
        const allPlots = embeddedDataManager.getAllPlots();
        
        allPlots.forEach(plot => {
          const excelData = embeddedDataManager.excelData.get(plot);
          if (excelData && excelData.status) {
            const status = excelData.status.toLowerCase();
            const regex = new RegExp(statusPattern, 'i');
            
            if (regex.test(status)) {
              const dbIds = embeddedDataManager.getElementsByPlot(plot);
              filteredDbIds.push(...dbIds);
              filteredPlots.push(plot);
            }
          }
        });
        
        if (filteredDbIds.length > 0) {
          // Isolate and fit view
          viewerManager.isolate(filteredDbIds);
          viewerManager.fitToView(filteredDbIds);
          
          // Reapply colors for filtered villas
          const colorScheme = document.getElementById('colorScheme')?.value || 'Status';
          await this.applyColorScheme(colorScheme);
          
          // Count filtered blocks
          const filteredBlocks = new Set();
          filteredPlots.forEach(plot => {
            const excelData = embeddedDataManager.excelData.get(plot);
            if (excelData && excelData.block) {
              filteredBlocks.add(String(excelData.block).trim());
            }
          });
          
          // Create block labels for filtered elements
          this.createBlockLabelsForElements(filteredDbIds, label);
          
          this.updateStatus(`Filtered ${filteredDbIds.length} elements in ${filteredBlocks.size} blocks for ${label}`, 'success');
        } else {
          this.updateStatus(`No elements found for ${label}`, 'warning');
        }
      }
      
      createBlockLabelsForElements(dbIds, context) {
        if (!window.embeddedDataManager || dbIds.length === 0) return;
        
        // Build block data structure from dbIds
        const blockMap = new Map();
        
        dbIds.forEach(dbId => {
          const element = embeddedDataManager.getElementData(dbId);
          if (element && element.block) {
            const block = String(element.block).trim();
            
            if (!blockMap.has(block)) {
              // Get contractor from schedule data (NOT from element.precaster)
              let contractor = null;
              if (window.dataParser && window.dataParser.scheduleByBlock) {
                const scheduleData = window.dataParser.scheduleByBlock.get(block);
                if (scheduleData && scheduleData.villas && scheduleData.villas.length > 0) {
                  contractor = scheduleData.villas[0].Contractor;
                }
              }
              
              blockMap.set(block, {
                dbIds: [],
                types: new Set(),
                contractor: contractor  // Use contractor from schedule
              });
            }
            
            const blockData = blockMap.get(block);
            blockData.dbIds.push(dbId);
            if (element.villaType) {
              blockData.types.add(element.villaType);
            }
          }
        });
        
        if (blockMap.size > 0) {
          console.log(`üè∑Ô∏è Creating labels for ${blockMap.size} blocks (${context})`);
          
          // Import and use the visual-block-identifier functions
          if (window.createBlockLabelsFromVisibleGeometry) {
            const colors = [
              '#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A', '#98D8C8',
              '#F7DC6F', '#BB8FCE', '#85C1E2', '#F8B88B', '#AED6F1',
              '#FF8C00', '#20B2AA', '#FFD700', '#FF1493', '#00CED1'
            ];
            
            // Clear old labels first
            if (window.clearBlockLabels) {
              window.clearBlockLabels();
            }
            
            // Create labels
            window.createBlockLabelsFromVisibleGeometry(blockMap, colors);
          }
        }
      }

      populateFilters() {
        // Populate Phase dropdown
        const phaseSelect = document.getElementById('filterPhase');
        const phases = embeddedDataManager.getAllPhases();
        phaseSelect.innerHTML = '<option value="">All</option>';
        phases.forEach(phase => {
          phaseSelect.innerHTML += `<option value="${phase}">${phase.toUpperCase()}</option>`;
        });

        // Populate Neighborhood dropdown
        const neighborhoodSelect = document.getElementById('filterNeighborhood');
        const neighborhoods = embeddedDataManager.getAllNeighborhoods();
        neighborhoodSelect.innerHTML = '<option value="">All</option>';
        neighborhoods.forEach(neighborhood => {
          neighborhoodSelect.innerHTML += `<option value="${neighborhood}">${neighborhood.toUpperCase()}</option>`;
        });

        // Populate Block dropdown
        const blockSelect = document.getElementById('filterBlock');
        const blocks = embeddedDataManager.getAllBlocks();
        blockSelect.innerHTML = '<option value="">All</option>';
        blocks.forEach(block => {
          blockSelect.innerHTML += `<option value="${block}">${block.toUpperCase()}</option>`;
        });

        // Populate Plot datalist
        const plotDatalist = document.getElementById('plotList');
        const plots = embeddedDataManager.getAllPlots();
        plotDatalist.innerHTML = '<option value="">All</option>';
        plots.forEach(plot => {
          plotDatalist.innerHTML += `<option value="${plot}">${plot}</option>`;
        });
      }

      applyFilters() {
        if (!this.dataAnalyzed) {
          this.updateStatus('Analyze model first', 'warning');
          return;
        }

        const phase = document.getElementById('filterPhase').value;
        const neighborhood = document.getElementById('filterNeighborhood').value;
        const block = document.getElementById('filterBlock').value;
        const plot = document.getElementById('filterPlot').value;

        // Collect all elements to show based on filters
        let filteredDbIds = [];
        let filteredPlots = [];

        if (plot) {
          // If plot selected, show only that plot
          filteredDbIds = embeddedDataManager.getElementsByPlot(plot);
          filteredPlots = [plot];
        } else if (block) {
          // If block selected, show entire block
          filteredDbIds = embeddedDataManager.getElementsByBlock(block);
          // Get all plots in this block
          const allPlots = embeddedDataManager.getAllPlots();
          filteredPlots = allPlots.filter(p => {
            const plotDbIds = embeddedDataManager.getElementsByPlot(p);
            return plotDbIds.some(id => filteredDbIds.includes(id));
          });
        } else if (neighborhood) {
          // If neighborhood selected, show entire neighborhood
          filteredDbIds = embeddedDataManager.getElementsByNeighborhood(neighborhood);
          // Get all plots in this neighborhood
          const allPlots = embeddedDataManager.getAllPlots();
          filteredPlots = allPlots.filter(p => {
            const plotDbIds = embeddedDataManager.getElementsByPlot(p);
            return plotDbIds.some(id => filteredDbIds.includes(id));
          });
        } else if (phase) {
          // If phase selected, show entire phase
          filteredDbIds = embeddedDataManager.getElementsByPhase(phase);
          // Get all plots in this phase
          const allPlots = embeddedDataManager.getAllPlots();
          filteredPlots = allPlots.filter(p => {
            const plotDbIds = embeddedDataManager.getElementsByPlot(p);
            return plotDbIds.some(id => filteredDbIds.includes(id));
          });
        }

        if (filteredDbIds.length > 0) {
          viewerManager.isolate(filteredDbIds);
          viewerManager.fitToView(filteredDbIds);
          
          // Close Gantt chart when applying sidebar filter (to avoid conflicts)
          if (window.ganttChart && typeof window.ganttChart.close === 'function') {
            const ganttWindow = document.querySelector('.gantt-window.visible');
            if (ganttWindow) {
              console.log('üìä Closing Gantt chart (sidebar filter active)');
              window.ganttChart.close();
            }
          }
          
          // Filter precaster labels to show only visible villas
          console.log(`üè∑Ô∏è Filtering precaster labels - found ${filteredPlots.length} visible plots from sidebar filter`);
          console.log(`   First 10 plots: ${filteredPlots.slice(0, 10).join(', ')}`);
          
          // Create precaster labels if they don't exist and we're in Status color scheme
          const currentScheme = document.getElementById('colorScheme')?.value;
          const labelsExist = document.getElementById('precasterLabels');
          
          if (currentScheme === 'Status' && !labelsExist) {
            console.log('   ‚ÑπÔ∏è Precaster labels not created yet, will filter after color scheme applies');
          } else if (embeddedColorManager && embeddedColorManager.filterPrecasterLabels) {
            embeddedColorManager.filterPrecasterLabels(filteredPlots);
            console.log(`   ‚úÖ Precaster filter applied - ${filteredPlots.length} visible`);
          } else {
            console.warn(`   ‚ö†Ô∏è embeddedColorManager not available or no filterPrecasterLabels method`);
          }
          
          // If neighborhood selected, show interactive block list and apply contractor colors
          if (neighborhood) {
            showInteractiveBlockList(neighborhood, filteredDbIds);
            
            // Apply contractor colors to blocks
            this.applyContractorColorsToFiltered(filteredDbIds, neighborhood);
            
            // Enable schedule toggle button
            const scheduleBtn = document.getElementById('toggleScheduleBtn');
            if (scheduleBtn) scheduleBtn.style.display = 'inline-block';
          }
          
          this.updateStatus(`Filtered: ${filteredDbIds.length} elements`, 'success');
        } else {
          this.updateStatus('No elements match the selected filters', 'warning');
        }
      }
      
      applyContractorColorsToFiltered(filteredDbIds, neighborhood) {
        // Group filtered elements by block
        const blockMap = new Map();
        
        // Get blocks from embeddedDataManager
        const allBlocks = embeddedDataManager.groupByBlock();
        
        for (const [blockKey, blockDbIds] of allBlocks.entries()) {
          // Check if any DBIds from this block are in filteredDbIds
          const blockFilteredDbIds = blockDbIds.filter(id => filteredDbIds.includes(id));
          
          if (blockFilteredDbIds.length > 0) {
            // Get contractor from schedule data using dataParser.scheduleByBlock
            let contractor = null;
            if (window.dataParser && window.dataParser.scheduleByBlock) {
              const scheduleData = window.dataParser.scheduleByBlock.get(blockKey);
              if (scheduleData && scheduleData.villas && scheduleData.villas.length > 0) {
                // Get contractor from first villa in the block (all villas in same block have same contractor)
                contractor = scheduleData.villas[0].Contractor;
                console.log(`   üìã Block ${blockKey}: Found contractor = ${contractor} (from ${scheduleData.villas.length} villas)`);
              } else {
                console.log(`   ‚ö†Ô∏è Block ${blockKey}: No schedule data found`);
              }
            }
            
            blockMap.set(blockKey, {
              block: blockKey,
              dbIds: blockFilteredDbIds,
              contractor: contractor
            });
          }
        }
        
        // Apply contractor colors
        const contractorColors = {
          'SPML': { r: 0, g: 102, b: 255, a: 1.0 },     // Blue (solid, no transparency)
          'ABR': { r: 255, g: 215, b: 0, a: 1.0 }        // Bright Gold (solid, no transparency)
        };
        const defaultColor = { r: 180, g: 180, b: 180, a: 0.5 };  // Gray for blocks without schedule
        
        let spmlCount = 0;
        let abrCount = 0;
        let noScheduleCount = 0;
        
        for (const [blockKey, blockInfo] of blockMap.entries()) {
          const contractor = blockInfo.contractor ? blockInfo.contractor.toUpperCase().trim() : null;
          const color = contractorColors[contractor] || defaultColor;
          
          blockInfo.dbIds.forEach(dbId => {
            viewerManager.setColor(dbId, color);
          });
          
          // Track counts
          if (contractor === 'SPML') {
            spmlCount++;
            console.log(`   ‚úÖ Block ${blockKey}: SPML (Blue) - ${blockInfo.dbIds.length} elements`);
          } else if (contractor === 'ABR') {
            abrCount++;
            console.log(`   ‚úÖ Block ${blockKey}: ABR (Gold) - ${blockInfo.dbIds.length} elements`);
          } else {
            noScheduleCount++;
            console.log(`   ‚ö™ Block ${blockKey}: No schedule (Gray) - ${blockInfo.dbIds.length} elements`);
          }
        }
        
        console.log(`üé® Applied contractor colors to ${blockMap.size} blocks in neighborhood ${neighborhood}`);
        console.log(`   üìä SPML (Blue): ${spmlCount} blocks | ABR (Gold): ${abrCount} blocks | No Schedule (Gray): ${noScheduleCount} blocks`);
      }

      clearFilters() {
        document.getElementById('filterPhase').value = '';
        document.getElementById('filterNeighborhood').value = '';
        document.getElementById('filterBlock').value = '';
        document.getElementById('filterPlot').value = '';
        
        // Close Block List and Schedule panels
        const blockPanel = document.getElementById('blockInfoPanel');
        if (blockPanel) blockPanel.remove();
        
        const schedulePanel = document.getElementById('permanentSchedulePanel');
        if (schedulePanel) schedulePanel.remove();
        
        // Clear precaster label filter
        if (window.embeddedColorManager) {
          window.embeddedColorManager.currentFilter = null;
          console.log('üßπ Cleared precaster filter');
        }
        
        // Show all without reapplying colors (Include Infra behavior)
        viewerManager.showAll();
        viewerManager.clearSelection();
        
        this.updateStatus('Filters cleared - showing all elements', 'success');
      }
      
      clearAll() {
        // Reset filter dropdowns
        document.getElementById('filterPhase').value = '';
        document.getElementById('filterNeighborhood').value = '';
        document.getElementById('filterBlock').value = '';
        document.getElementById('filterPlot').value = '';
        
        // Close Block List and Schedule panels
        const blockPanel = document.getElementById('blockInfoPanel');
        if (blockPanel) blockPanel.remove();
        
        const schedulePanel = document.getElementById('permanentSchedulePanel');
        if (schedulePanel) schedulePanel.remove();

        // Clear block labels
        if (window.clearBlockLabels) {
          window.clearBlockLabels();
        }

        // Clear precaster labels
        if (window.embeddedColorManager) {
          window.embeddedColorManager.clearPrecasterLabels();
          window.embeddedColorManager.currentFilter = null;
        }

        // Clear colors
        if (window.viewerManager) {
          window.viewerManager.clearColors();
        }
        
        // Show all elements
        viewerManager.showAll();
        viewerManager.clearSelection();

        // Reset color scheme dropdown
        const colorScheme = document.getElementById('colorScheme');
        if (colorScheme) {
          colorScheme.value = 'None';
        }

        // Clear legend
        const legendDiv = document.getElementById('legend');
        if (legendDiv) {
          legendDiv.innerHTML = '';
        }

        console.log('üßπ‚ú® All labels, filters, and colors cleared');
        this.updateStatus('Everything cleared', 'success');
      }

      resetEverything() {
        console.log('üîÑ Resetting everything...');

        // Clear all first
        this.clearAll();

        // Close Gantt chart if open
        if (window.ganttChart) {
          window.ganttChart.close();
        }

        // Reset camera to home view
        if (window.viewerManager && window.viewerManager.viewer) {
          window.viewerManager.viewer.navigation.setRequestHomeView(true);
        }

        // Reapply default color scheme
        setTimeout(() => {
          const colorScheme = document.getElementById('colorScheme');
          if (colorScheme && this.dataAnalyzed) {
            colorScheme.value = 'Block';
            this.applyColorScheme('Block');
          }
          
          // Reinitialize zoom behavior after reset (same as initial load)
          setTimeout(() => {
            this.initializeZoom();
          }, 500);
        }, 100);

        this.updateStatus('Reset complete - All views restored to default', 'success');
        console.log('‚úÖ Reset complete');
      }

      async loadScheduleFile(file) {
        try {
          const scheduleStatus = document.getElementById('scheduleStatus');
          scheduleStatus.textContent = 'Loading...';
          scheduleStatus.style.color = '#666';
          
          console.log(`üìÖ Loading schedule file: ${file.name}`);
          
          // Parse Excel file
          await dataParser.parseExcelFile(file);
          
          // Load Excel data into embeddedDataManager for status/precaster mapping
          if (window.embeddedDataManager) {
            window.embeddedDataManager.loadExcelData(dataParser);
            console.log('‚úÖ Excel data loaded into embeddedDataManager');
          }
          
          // Update status
          const blockCount = dataParser.scheduleByBlock.size;
          scheduleStatus.textContent = `‚úÖ Loaded ${blockCount} blocks`;
          scheduleStatus.style.color = '#009A84';
          
          console.log(`‚úÖ Schedule loaded: ${blockCount} blocks`);
          
          // Refresh Gantt chart if it exists
          if (window.ganttChart) {
            window.ganttChart.refresh();
          }
          
          // Refresh schedule panel if it exists
          if (window._currentBlockMap) {
            const existing = document.getElementById('permanentSchedulePanel');
            if (existing) {
              existing.remove();
              // Import createSchedulePanel from visual-block-identifier
              const { showInteractiveBlockList } = await import('./js/visual-block-identifier.js');
              const neighborhood = document.getElementById('filterNeighborhood').value;
              if (neighborhood && window._currentBlockMap) {
                // Recreate schedule panel with new data
                window.location.reload(); // Simple refresh for now
              }
            }
          }
          
        } catch (error) {
          console.error('‚ùå Schedule loading error:', error);
          const scheduleStatus = document.getElementById('scheduleStatus');
          scheduleStatus.textContent = '‚ùå Error loading file';
          scheduleStatus.style.color = '#dc3545';
        }
      }

      updateLegend() {
        const legendDiv = document.getElementById('legend');
        if (!legendDiv) return;

        let html = '';

        // Color scheme legend
        const legendItems = embeddedColorManager.getLegend();
        if (legendItems.length > 0) {
          html += '<div class="legend-container"><h4>Color Legend</h4>';
          legendItems.forEach(item => {
            const rgbColor = `rgb(${item.color.r}, ${item.color.g}, ${item.color.b})`;
            html += `
              <div class="legend-item">
                <div class="legend-color" style="background: ${rgbColor};"></div>
                <span class="legend-label">${item.label}</span>
                <span class="legend-count">(${item.count})</span>
              </div>
            `;
          });
          html += '</div>';
        }

        // Contractor legend (for construction activity labels)
        const contractorItems = embeddedColorManager.getContractorLegend();
        if (contractorItems.length > 0) {
          html += '<div class="legend-container"><h4>Contractor Labels</h4>';
          contractorItems.forEach(item => {
            const rgbColor = `rgb(${item.color.r}, ${item.color.g}, ${item.color.b})`;
            html += `
              <div class="legend-item">
                <div class="legend-color" style="background: ${rgbColor}; border-radius: 50%; width: 20px; height: 20px;"></div>
                <span class="legend-label">${item.label}</span>
              </div>
            `;
          });
          html += '</div>';
        }

        // Precaster legend
        const precasterItems = embeddedColorManager.getPrecasterLegend();
        if (precasterItems.length > 0) {
          html += '<div class="legend-container"><h4>Precasters</h4>';
          precasterItems.forEach(item => {
            html += `
              <div class="legend-item">
                <span class="legend-label" style="font-size: 11px;">${item.label}</span>
              </div>
            `;
          });
          html += '</div>';
        }

        legendDiv.innerHTML = html;
      }

      updateLegendsPanel(scheme) {
        const legendsPanel = document.getElementById('legendsPanel');
        if (!legendsPanel) return;

        // Show legends panel based on color scheme
        if (scheme === 'Status' || scheme === 'Block') {
          legendsPanel.style.display = 'block';
        } else {
          legendsPanel.style.display = 'none';
        }
      }

      updateStats() {
        const data = embeddedDataManager.exportData();
        const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'model-data-export.json';
        a.click();
        URL.revokeObjectURL(url);
        this.updateStatus('Data exported', 'success');
      }

      async debugProperties() {
        console.log('üîç === SEARCHING FOR REVIT ELEMENTS (SMART SEARCH) ===');
        const allDbIds = await viewerManager.getAllDbIds();

        if (allDbIds.length === 0) {
          console.error('No elements found in model');
          return;
        }

        console.log(`Total elements in model: ${allDbIds.length}`);
        console.log('Strategy: Search beginning, middle, and end of model...');

        // Search through DIFFERENT parts of the model (beginning, middle, end)
        let foundRevitElements = [];
        const SAMPLES = [
          { start: 0, count: 500, label: 'Beginning (0-500)' },
          { start: Math.floor(allDbIds.length * 0.25), count: 500, label: 'Quarter (25%)' },
          { start: Math.floor(allDbIds.length * 0.50), count: 500, label: 'Middle (50%)' },
          { start: Math.floor(allDbIds.length * 0.75), count: 500, label: 'Three-Quarter (75%)' },
          { start: Math.max(0, allDbIds.length - 500), count: 500, label: 'End (last 500)' }
        ];

        for (const sample of SAMPLES) {
          console.log(`\nüîé Searching ${sample.label}...`);
          const startIdx = sample.start;
          const endIdx = Math.min(startIdx + sample.count, allDbIds.length);

          for (let i = startIdx; i < endIdx; i++) {
            const dbId = allDbIds[i];
            const props = await viewerManager.getBulkProperties([dbId], null);

            if (props && props.length > 0) {
              const elementProps = props[0].properties;

              // Check if this element has Revit properties OR source file
              const hasRevitProps = elementProps.some(p =>
                p.displayName === 'Element/Block' ||
                p.displayName === 'Element/Plot' ||
                p.displayName === 'Element/Villa_Type'
              );

              const sourceFile = elementProps.find(p => p.displayName === 'Item/Source File' || p.displayName === 'Source File');
              const isRevitFile = sourceFile && sourceFile.displayValue && sourceFile.displayValue.includes('.rvt');

              if (hasRevitProps) {
                foundRevitElements.push(dbId);

                if (foundRevitElements.length <= 5) {
                  console.log(`\n‚úÖ FOUND REVIT ELEMENT ${dbId} in ${sample.label}:`);
                  elementProps
                    .filter(p => p.displayValue && p.displayValue !== '' && p.displayName.includes('Element/'))
                    .forEach(p => {
                      console.log(`  "${p.displayName}" = "${p.displayValue}"`);
                    });

                  const extracted = embeddedDataManager.extractElementInfo(elementProps);
                  console.log('Extracted:', extracted);
                }
              } else if (isRevitFile && i === startIdx) {
                // Show first .rvt file found in each section
                console.log(`  Found .rvt element at dbId ${dbId}: ${sourceFile.displayValue}`);
              }
            }

            // Progress indicator
            if ((i - startIdx) % 100 === 0) {
              console.log(`  Progress: ${i - startIdx}/${sample.count} in ${sample.label}... Found ${foundRevitElements.length} total`);
            }
          }

          if (foundRevitElements.length > 0) {
            console.log(`‚úì Found ${foundRevitElements.length} Revit elements so far!`);
            break; // Stop searching once we find some
          }
        }

        console.log(`\nüìä SEARCH COMPLETE:`);
        console.log(`  Total elements in model: ${allDbIds.length}`);
        console.log(`  Found Revit elements: ${foundRevitElements.length}`);
        console.log(`  Revit element IDs: ${foundRevitElements.slice(0, 10).join(', ')}${foundRevitElements.length > 10 ? '...' : ''}`);

        this.updateStatus(`Found ${foundRevitElements.length} Revit elements - check console`, 'success');

        // If no elements found, try deep search in nested files
        if (foundRevitElements.length === 0) {
          console.log('\nüîç No Revit properties found in top-level search.');
          console.log('Starting DEEP SEARCH in nested Revit files...');
          await this.deepSearchNestedFiles();
        }
      }

      async deepSearchNestedFiles() {
        console.log('\n=== DEEP SEARCH: Checking Known .rvt File Areas ===');

        // We know from earlier search that these .rvt files exist:
        // - dbId 310272: Test power BI_Ali_ElraeiJZDC9.rvt (this is the villa file!)
        // - dbId 176026: 00910-PCM-CIW-BR1-PIM-SE-000001.rvt

        const revitFileDbIds = [310272, 176026];

        for (const fileDbId of revitFileDbIds) {
          console.log(`\nüîé Searching around dbId ${fileDbId}...`);

          // Try elements AFTER this file node (likely where actual elements are)
          const searchRange = 200; // Check 200 elements after the file node
          let foundCount = 0;

          for (let offset = 1; offset <= searchRange && foundCount < 5; offset++) {
            const testDbId = fileDbId + offset;

            try {
              const props = await viewerManager.getBulkProperties([testDbId], null);

              if (props && props.length > 0) {
                const elementProps = props[0].properties;

                // Check source file to see if it's from the villa .rvt
                const sourceFile = elementProps.find(p =>
                  p.displayName === 'Item/Source File' || p.displayName === 'Source File'
                );

                if (sourceFile && sourceFile.displayValue && sourceFile.displayValue.includes('power BI')) {
                  // This element is from the villa file!
                  const hasBlock = elementProps.find(p => p.displayName === 'Element/Block');
                  const hasPlot = elementProps.find(p => p.displayName === 'Element/Plot');
                  const hasVillaType = elementProps.find(p => p.displayName === 'Element/Villa_Type');

                  if (hasBlock || hasPlot || hasVillaType) {
                    console.log(`\n‚úÖ FOUND REVIT ELEMENT! DbId: ${testDbId}`);
                    console.log(`Source: ${sourceFile.displayValue}`);
                    elementProps
                      .filter(p => p.displayValue && p.displayValue !== '' && p.displayName.startsWith('Element/'))
                      .forEach(p => console.log(`  ${p.displayName} = ${p.displayValue}`));

                    const extracted = embeddedDataManager.extractElementInfo(elementProps);
                    console.log('Extracted:', extracted);

                    foundCount++;
                  } else if (offset <= 10) {
                    // Show first 10 villa file elements even without Block/Plot
                    console.log(`  DbId ${testDbId}: From ${sourceFile.displayValue} but no Element/Block or Plot`);

                    // Show ALL properties for first element to see what's available
                    if (offset === 1) {
                      console.log('\nüìã ALL PROPERTIES FOR FIRST VILLA ELEMENT (dbId ' + testDbId + '):');
                      elementProps
                        .filter(p => p.displayValue && p.displayValue !== '')
                        .forEach(p => console.log(`  "${p.displayName}" = "${p.displayValue}"`));
                    }
                  }
                }
              }
            } catch (e) {
              // Element doesn't exist, skip
            }

            if (offset % 50 === 0) {
              console.log(`  Checked ${offset}/${searchRange} elements...`);
            }
          }

          if (foundCount > 0) {
            console.log(`\n‚úì Found ${foundCount} elements with Revit properties near dbId ${fileDbId}!`);
            return; // Success
          }
        }

        console.log('\n‚ùå Deep search complete - properties may be stored differently in this Navisworks file');
        console.log('üí° Searching for LEAF NODES (actual geometry) with properties...');

        await this.searchLeafNodes();
      }

      async searchLeafNodes() {
        console.log('\n=== SEARCHING LEAF NODES (GEOMETRY) ===');

        const instanceTree = viewerManager.viewer.model.getInstanceTree();
        if (!instanceTree) {
          console.error('Instance tree not available');
          return;
        }

        // Collect all leaf nodes (nodes with no children = actual geometry)
        const leafNodes = [];
        const allDbIds = await viewerManager.getAllDbIds();

        console.log(`Checking ${allDbIds.length} nodes for leaf nodes...`);

        for (let i = 0; i < allDbIds.length && leafNodes.length < 500; i++) {
          const dbId = allDbIds[i];

          // Check if this node has children
          let hasChildren = false;
          instanceTree.enumNodeChildren(dbId, () => {
            hasChildren = true;
          });

          if (!hasChildren) {
            leafNodes.push(dbId);
          }

          if (i % 10000 === 0) {
            console.log(`  Scanned ${i}/${allDbIds.length}... Found ${leafNodes.length} leaf nodes`);
          }
        }

        console.log(`\nFound ${leafNodes.length} leaf nodes (actual geometry elements)`);
        console.log(`Checking first 50 leaf nodes for Revit properties...`);

        // Check leaf nodes for properties
        let foundWithProps = 0;
        for (let i = 0; i < Math.min(50, leafNodes.length); i++) {
          const dbId = leafNodes[i];

          try {
            const props = await viewerManager.getBulkProperties([dbId], null);

            if (props && props.length > 0) {
              const elementProps = props[0].properties;

              const hasBlock = elementProps.find(p => p.displayName === 'Element/Block');
              const hasPlot = elementProps.find(p => p.displayName === 'Element/Plot');
              const sourceFile = elementProps.find(p =>
                (p.displayName === 'Item/Source File' || p.displayName === 'Source File') &&
                p.displayValue && p.displayValue.includes('power BI')
              );

              if ((hasBlock || hasPlot) && sourceFile) {
                console.log(`\n‚úÖ FOUND LEAF NODE WITH PROPERTIES! DbId: ${dbId}`);
                elementProps
                  .filter(p => p.displayValue && p.displayValue !== '' && p.displayName.startsWith('Element/'))
                  .forEach(p => console.log(`  ${p.displayName} = ${p.displayValue}`));

                foundWithProps++;
              } else if (sourceFile && foundWithProps === 0 && i < 5) {
                // Show first few villa leaf nodes
                console.log(`  Leaf ${dbId}: From villa file but no Element/Block`);
                const allProps = elementProps.filter(p => p.displayValue && p.displayValue !== '').map(p => p.displayName);
                console.log(`    Available props: ${allProps.slice(0, 10).join(', ')}`);
              }
            }
          } catch (e) {
            // Skip
          }
        }

        if (foundWithProps === 0) {
          console.log('\n‚ùå Leaf nodes also do not contain Element/Block or Element/Plot properties via getBulkProperties()');
          console.log('üîÑ Trying property database search...');
          await this.searchPropertyDatabase();
        } else {
          console.log(`\n‚úÖ Found ${foundWithProps} leaf nodes with Revit properties!`);
        }
      }

      async searchPropertyDatabase() {
        console.log('\n=== SEARCHING PROPERTY DATABASE DIRECTLY ===');

        try {
          // STEP 1: Get all available property names first (sample 100 elements with timeout)
          console.log('üìã Step 1: Sampling property names from 100 elements (10 second timeout)...');
          const allPropertyNames = await viewerManager.getAllPropertyNames(100);

          console.log(`‚úÖ Found ${allPropertyNames.length} unique property names in sample`);

          // Filter for potentially relevant properties
          const relevantProps = allPropertyNames.filter(name =>
            name.includes('Element') ||
            name.includes('Plot') ||
            name.includes('Block') ||
            name.includes('Villa') ||
            name.includes('NBH') ||
            name.includes('Phase') ||
            name.includes('Level')
          );

          if (relevantProps.length > 0) {
            console.log(`\nüìä Found ${relevantProps.length} potentially relevant properties:`);
            relevantProps.forEach(name => console.log(`  - ${name}`));
          } else {
            console.log('\n‚ö†Ô∏è No Element/, Plot, Block, Villa, NBH, Phase, or Level properties found in sample');
            console.log('\nüìã First 30 property names found in model:');
            allPropertyNames.slice(0, 30).forEach(name => console.log(`  - ${name}`));
          }

          // STEP 2: Search for specific Revit property names
          console.log('\nüìã Step 2: Searching for specific Revit properties...');
          const searchTerms = ['Element/Block', 'Element/Plot', 'Element/Villa_Type', 'Element/NBH', 'Plot', 'Block'];

          for (const term of searchTerms) {
            console.log(`\nüîé Searching for "${term}" (max 10 results)...`);
            const results = await viewerManager.searchPropertiesInDb(term, 10);

            if (results.length > 0) {
              console.log(`‚úÖ FOUND ${results.length} elements with "${term}" property!`);
              console.log('Matches:');
              results.forEach(r => {
                console.log(`  DbId ${r.dbId}: ${r.propertyName} = ${r.value}`);
              });

              // If we found properties, update the extraction to use property database
              console.log('\nüéâ SUCCESS! Properties ARE in the model - accessible via property database');
              console.log('üìã The extraction code needs to be updated to use the property database API');
              return;
            } else {
              console.log(`  ‚ùå No matches found for "${term}"`);
            }
          }

          console.log('\n‚ùå Property database search complete - no Revit custom parameters found');
          console.log('üî¥ CRITICAL: The Navisworks translation did NOT preserve Revit custom parameters');
          console.log('\nüìã RECOMMENDED SOLUTIONS:');
          console.log('   1. Re-translate the model with property extraction enabled (see RETRANSLATION_GUIDE.md)');
          console.log('   2. Upload the Revit .rvt file directly instead of the Navisworks .nwd file');
          console.log('   3. Check if properties are named differently (review property list above)');

        } catch (error) {
          console.error('‚ùå Property database search failed:', error.message);
          console.log('üìã Falling back to re-translation solution');
        }
      }

      updateStatus(message, type = 'info') {
        const statusDiv = document.getElementById('status');
        if (statusDiv) {
          statusDiv.textContent = message;
          statusDiv.className = `status status-${type}`;
          console.log(`[${type.toUpperCase()}] ${message}`);
        }
      }

      enableControls() {
        const controls = [
          'colorScheme',
          'showAllBtn',
          'fitViewBtn',
          'exportDataBtn',
          'debugPropsBtn',
          'analyzeBtn',
          'filterPhase',
          'filterNeighborhood',
          'filterBlock',
          'filterPlot',
          'applyFiltersBtn',
          'clearFiltersBtn'
        ];
        controls.forEach(id => {
          const element = document.getElementById(id);
          if (element) element.disabled = false;
        });
      }

      checkAuthStatus() {
        this.isAuthenticated = authManager.isAuthenticated();

        const loginBtn = document.getElementById('loginBtn');
        const logoutBtn = document.getElementById('logoutBtn');
        const loadModelBtn = document.getElementById('loadModelBtn');
        const authStatusText = document.getElementById('authStatusText');

        if (this.isAuthenticated) {
          if (loginBtn) loginBtn.style.display = 'none';
          if (logoutBtn) logoutBtn.style.display = 'inline-block';
          if (loadModelBtn) loadModelBtn.disabled = false;
          if (authStatusText) authStatusText.textContent = '‚úÖ Logged in';
          this.updateStatus('Logged in - Ready to load model', 'success');
        } else {
          if (loginBtn) loginBtn.style.display = 'inline-block';
          if (logoutBtn) logoutBtn.style.display = 'none';
          if (loadModelBtn) loadModelBtn.disabled = true;
          if (authStatusText) authStatusText.textContent = '‚ö†Ô∏è Not logged in';
        }
      }

      handleLogin() {
        authManager.openLoginPopup();
        this.updateStatus('Please complete login in popup...', 'info');
      }

      handleLogout() {
        authManager.logout();
        this.checkAuthStatus();
        this.updateStatus('Logged out', 'info');
        if (this.modelLoaded) {
          this.modelLoaded = false;
          this.dataAnalyzed = false;
          viewerManager.destroy();
        }
      }
    }

    // Initialize dashboard
    const dashboard = new Dashboard();
    document.addEventListener('DOMContentLoaded', () => {
      dashboard.init();
    });

    // Make dashboard accessible globally for debugging
    window.dashboard = dashboard;
    window.embeddedDataManager = embeddedDataManager;
    window.viewerManager = viewerManager;
    window.ganttChart = ganttChart;
    window.findExactPropertyNames = findExactPropertyNames;
    window.findVillaElements = findVillaElements;
    window.searchForRealVillas = searchForRealVillas;
    window.exploreModelStructure = exploreModelStructure;
    window.findVillaNodes = findVillaNodes;
    window.exploreInstanceTree = exploreInstanceTree;
    window.exploreFederatedModels = exploreFederatedModels;
    window.exploreDocumentStructure = exploreDocumentStructure;
    window.extractVillaModelData = extractVillaModelData;
    window.findNestedModels = findNestedModels;
    window.checkModelReferences = checkModelReferences;
    window.extractVillaDataFromNode = extractVillaDataFromNode;
    window.debugColorByNeighborhood = debugColorByNeighborhood;
    window.testColoring = testColoring;
    window.showInteractiveBlockList = showInteractiveBlockList;
    window.hideBlockLabels = hideBlockLabels;
    window.diagnosticAnalysis = diagnosticAnalysis;
  </script>

  <!-- Gantt Chart Floating Window -->
  <div id="ganttWindow" class="gantt-window">
    <div class="gantt-header">
      <div class="gantt-title">
        <span>üìä Schedule Gantt Chart</span>
      </div>
      <div class="gantt-controls">
        <button id="ganttClose" class="gantt-btn" title="Close">√ó</button>
      </div>
    </div>
    <div class="gantt-toolbar">
      <div class="gantt-filter-group">
        <div class="gantt-date-range-group">
          <label>From:</label>
          <input type="date" id="ganttStartDate" class="gantt-date-input">
          <label>To:</label>
          <input type="date" id="ganttEndDate" class="gantt-date-input">
        </div>
        <div class="gantt-action-buttons">
          <button id="ganttTodayBtn" class="gantt-btn-filter" title="Jump to today's date">üìÖ Today</button>
          <button id="ganttResetTodayBtn" class="gantt-btn-filter" title="Reset Today line to actual date">üîÑ Reset Today</button>
          <button id="ganttApplyFilter" class="gantt-btn-filter">Apply</button>
          <button id="ganttResetFilter" class="gantt-btn-filter">Reset</button>
        </div>
      </div>
      <div class="gantt-view-group">
        <label>
          <input type="checkbox" id="ganttShowVillas">
          Show Villas in Chart
        </label>
        <label>
          <input type="checkbox" id="ganttFilterModel">
          Filter Current Activities
        </label>
      </div>
    </div>
    <div class="gantt-content" id="ganttContent">
      <div class="gantt-timeline" id="ganttTimeline"></div>
      <div class="gantt-tasks" id="ganttTasks"></div>
    </div>
  </div>


</body>
</html>
